--- a/net/minecraft/client/gui/GuiIngame.java
+++ b/net/minecraft/client/gui/GuiIngame.java
@@ -11,6 +11,9 @@
 import java.util.Random;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
+
+import org.lwjgl.opengl.GL11;
+
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.GameSettings;
 import net.minecraft.client.Minecraft;
@@ -21,6 +24,8 @@
 import net.minecraft.client.gui.inventory.GuiContainer;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GlStateManager;
+import net.minecraft.client.renderer.GlStateManager.DestFactor;
+import net.minecraft.client.renderer.GlStateManager.SourceFactor;
 import net.minecraft.client.renderer.ItemRenderer;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.RenderHelper;
@@ -68,128 +73,135 @@
 
 public class GuiIngame extends Gui
 {
-    private static final ResourceLocation VIGNETTE_TEX_PATH = new ResourceLocation("textures/misc/vignette.png");
-    private static final ResourceLocation WIDGETS_TEX_PATH = new ResourceLocation("textures/gui/widgets.png");
-    private static final ResourceLocation PUMPKIN_BLUR_TEX_PATH = new ResourceLocation("textures/misc/pumpkinblur.png");
-    private final Random rand = new Random();
-    private final Minecraft mc;
-    private final ItemRenderer itemRenderer;
-
-    /** ChatGUI instance that retains all previous chat data */
-    private final GuiNewChat persistantChatGUI;
-    private int ticks;
-
-    /** The string specifying which record music is playing */
-    private String overlayMessage = "";
-
-    /** How many ticks the record playing message will be displayed */
-    private int overlayMessageTime;
-    private boolean animateOverlayMessageColor;
-
-    /** Previous frame vignette brightness (slowly changes by 1% each frame) */
-    public float prevVignetteBrightness = 1.0F;
-
-    /** Remaining ticks the item highlight should be visible */
-    private int remainingHighlightTicks;
-
-    /** The ItemStack that is currently being highlighted */
-    private ItemStack highlightingItemStack = ItemStack.EMPTY;
-    private final GuiOverlayDebug overlayDebug;
-    private final GuiSubtitleOverlay overlaySubtitle;
-
-    /** The spectator GUI for this in-game GUI instance */
-    private final GuiSpectator spectatorGui;
-    private final GuiPlayerTabOverlay overlayPlayerList;
-    private final GuiBossOverlay overlayBoss;
-
-    /** A timer for the current title and subtitle displayed */
-    private int titlesTimer;
-
-    /** The current title displayed */
-    private String displayedTitle = "";
-
-    /** The current sub-title displayed */
-    private String displayedSubTitle = "";
-
-    /** The time that the title take to fade in */
-    private int titleFadeIn;
-
-    /** The time that the title is display */
-    private int titleDisplayTime;
-
-    /** The time that the title take to fade out */
-    private int titleFadeOut;
-    private int playerHealth;
-    private int lastPlayerHealth;
-
-    /** The last recorded system time */
-    private long lastSystemTime;
-
-    /** Used with updateCounter to make the heart bar flash */
-    private long healthUpdateCounter;
-    private int scaledWidth;
-    private int scaledHeight;
-    private final Map<ChatType, List<IChatListener>> chatListeners = Maps.<ChatType, List<IChatListener>>newHashMap();
-
-    public GuiIngame(Minecraft mcIn)
-    {
-        this.mc = mcIn;
-        this.itemRenderer = mcIn.getItemRenderer();
-        this.overlayDebug = new GuiOverlayDebug(mcIn);
-        this.spectatorGui = new GuiSpectator(mcIn);
-        this.persistantChatGUI = new GuiNewChat(mcIn);
-        this.overlayPlayerList = new GuiPlayerTabOverlay(mcIn, this);
-        this.overlayBoss = new GuiBossOverlay(mcIn);
-        this.overlaySubtitle = new GuiSubtitleOverlay(mcIn);
-
-        for (ChatType chattype : ChatType.values())
-        {
-            this.chatListeners.put(chattype, Lists.<IChatListener>newArrayList());
-        }
-
-        IChatListener ichatlistener = NarratorChatListener.INSTANCE;
-        (this.chatListeners.get(ChatType.CHAT)).add(new NormalChatListener(mcIn));
-        (this.chatListeners.get(ChatType.CHAT)).add(ichatlistener);
-        (this.chatListeners.get(ChatType.SYSTEM)).add(new NormalChatListener(mcIn));
-        (this.chatListeners.get(ChatType.SYSTEM)).add(ichatlistener);
-        (this.chatListeners.get(ChatType.GAME_INFO)).add(new OverlayChatListener(mcIn));
-        this.setDefaultTitlesTimes();
-    }
-
-    /**
-     * Set the differents times for the titles to their default values
-     */
-    public void setDefaultTitlesTimes()
-    {
-        this.titleFadeIn = 10;
-        this.titleDisplayTime = 70;
-        this.titleFadeOut = 20;
-    }
-
-    public void renderGameOverlay(float partialTicks)
-    {
-        this.scaledWidth = this.mc.mainWindow.getScaledWidth();
-        this.scaledHeight = this.mc.mainWindow.getScaledHeight();
-        FontRenderer fontrenderer = this.getFontRenderer();
-        GlStateManager.enableBlend();
-
-        if (Config.isVignetteEnabled())
-        {
-            this.renderVignette(this.mc.getRenderViewEntity());
-        }
-        else
-        {
-            GlStateManager.enableDepthTest();
-            GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-        }
-
-        ItemStack itemstack = this.mc.player.inventory.armorItemInSlot(3);
-
-        if (this.mc.gameSettings.thirdPersonView == 0 && itemstack.getItem() == Blocks.CARVED_PUMPKIN.asItem())
-        {
-            this.renderPumpkinOverlay();
-        }
+	private static final ResourceLocation VIGNETTE_TEX_PATH = new ResourceLocation("textures/misc/vignette.png");
+	private static final ResourceLocation WIDGETS_TEX_PATH = new ResourceLocation("textures/gui/widgets.png");
+	private static final ResourceLocation PUMPKIN_BLUR_TEX_PATH = new ResourceLocation("textures/misc/pumpkinblur.png");
+	private final Random rand = new Random();
+	private final Minecraft mc;
+	private final ItemRenderer itemRenderer;
+
+	/** ChatGUI instance that retains all previous chat data */
+	private final GuiNewChat persistantChatGUI;
+	private int ticks;
+
+	/** The string specifying which record music is playing */
+	private String overlayMessage = "";
+
+	/** How many ticks the record playing message will be displayed */
+	private int overlayMessageTime;
+	private boolean animateOverlayMessageColor;
+
+	/** Previous frame vignette brightness (slowly changes by 1% each frame) */
+	public float prevVignetteBrightness = 1.0F;
+
+	/** Remaining ticks the item highlight should be visible */
+	private int remainingHighlightTicks;
+
+	/** The ItemStack that is currently being highlighted */
+	private ItemStack highlightingItemStack = ItemStack.EMPTY;
+	public final GuiOverlayDebug overlayDebug;
+	private final GuiSubtitleOverlay overlaySubtitle;
+
+	/** The spectator GUI for this in-game GUI instance */
+	private final GuiSpectator spectatorGui;
+	private final GuiPlayerTabOverlay overlayPlayerList;
+	private final GuiBossOverlay overlayBoss;
+
+	/** A timer for the current title and subtitle displayed */
+	private int titlesTimer;
+
+	/** The current title displayed */
+	private String displayedTitle = "";
+
+	/** The current sub-title displayed */
+	private String displayedSubTitle = "";
+
+	/** The time that the title take to fade in */
+	private int titleFadeIn;
+
+	/** The time that the title is display */
+	private int titleDisplayTime;
+
+	/** The time that the title take to fade out */
+	private int titleFadeOut;
+	private int playerHealth;
+	private int lastPlayerHealth;
+
+	/** The last recorded system time */
+	private long lastSystemTime;
+
+	/** Used with updateCounter to make the heart bar flash */
+	private long healthUpdateCounter;
+	private int scaledWidth;
+	private int scaledHeight;
+	private final Map<ChatType, List<IChatListener>> chatListeners = Maps.<ChatType, List<IChatListener>>newHashMap();
+
+	public GuiIngame(Minecraft mcIn)
+	{
+		this.mc = mcIn;
+		this.itemRenderer = mcIn.getItemRenderer();
+		this.overlayDebug = new GuiOverlayDebug(mcIn);
+		this.spectatorGui = new GuiSpectator(mcIn);
+		this.persistantChatGUI = new GuiNewChat(mcIn);
+		this.overlayPlayerList = new GuiPlayerTabOverlay(mcIn, this);
+		this.overlayBoss = new GuiBossOverlay(mcIn);
+		this.overlaySubtitle = new GuiSubtitleOverlay(mcIn);
+
+		for (ChatType chattype : ChatType.values())
+		{
+			this.chatListeners.put(chattype, Lists.<IChatListener>newArrayList());
+		}
+
+		IChatListener ichatlistener = NarratorChatListener.INSTANCE;
+		(this.chatListeners.get(ChatType.CHAT)).add(new NormalChatListener(mcIn));
+		(this.chatListeners.get(ChatType.CHAT)).add(ichatlistener);
+		(this.chatListeners.get(ChatType.SYSTEM)).add(new NormalChatListener(mcIn));
+		(this.chatListeners.get(ChatType.SYSTEM)).add(ichatlistener);
+		(this.chatListeners.get(ChatType.GAME_INFO)).add(new OverlayChatListener(mcIn));
+		this.setDefaultTitlesTimes();
+	}
+
+	/**
+	 * Set the differents times for the titles to their default values
+	 */
+	public void setDefaultTitlesTimes()
+	{
+		this.titleFadeIn = 10;
+		this.titleDisplayTime = 70;
+		this.titleFadeOut = 20;
+	}
+
+	public void renderGameOverlay(float partialTicks)
+	{
+		this.scaledWidth = this.mc.mainWindow.getScaledWidth();
+		this.scaledHeight = this.mc.mainWindow.getScaledHeight();
+		FontRenderer fontrenderer = this.getFontRenderer();
+		GlStateManager.enableBlend();
+
+		// VIVECRAFT: lol no
+		/*if (Config.isVignetteEnabled())
+		{
+			this.renderVignette(this.mc.getRenderViewEntity());
+		}
+		else
+		{*/
+			GlStateManager.enableDepthTest();
+			// VIVECRAFT: DestFactor of ONE is really what we want here, because math
+			GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+		//}
+
+		ItemStack itemstack = this.mc.player.inventory.armorItemInSlot(3);
+
+		//VIVECRAFT - srsly.
+		mc.pumpkineffect = 0;
+		if (this.mc.gameSettings.thirdPersonView == 0 && itemstack.getItem() == Blocks.CARVED_PUMPKIN.asItem())
+		{
+			mc.pumpkineffect = 1f;
+			//this.renderPumpkinOverlay();
+		}
+		//
 
+		/* VIVECRAFT - no no no.
         if (!this.mc.player.isPotionActive(MobEffects.NAUSEA))
         {
             float f = this.mc.player.prevTimeInPortal + (this.mc.player.timeInPortal - this.mc.player.prevTimeInPortal) * partialTicks;
@@ -199,1302 +211,1395 @@
                 this.renderPortal(f);
             }
         }
+		 */
 
-        if (this.mc.playerController.getCurrentGameType() == GameType.SPECTATOR)
-        {
-            this.spectatorGui.renderTooltip(partialTicks);
-        }
-        else if (!this.mc.gameSettings.hideGUI)
-        {
-            this.renderHotbar(partialTicks);
-        }
-
-        if (!this.mc.gameSettings.hideGUI)
-        {
-            GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
-            this.mc.getTextureManager().bindTexture(ICONS);
-            GlStateManager.enableBlend();
-            GlStateManager.enableAlphaTest();
-            this.renderAttackIndicator(partialTicks);
-            GlStateManager.enableAlphaTest();
-            GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-            this.mc.profiler.startSection("bossHealth");
-            this.overlayBoss.renderBossHealth();
-            this.mc.profiler.endSection();
-            GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
-            this.mc.getTextureManager().bindTexture(ICONS);
-
-            if (this.mc.playerController.shouldDrawHUD())
-            {
-                this.renderPlayerStats();
-            }
-
-            this.renderVehicleHealth();
-            GlStateManager.disableBlend();
-            int k = this.scaledWidth / 2 - 91;
-
-            if (this.mc.player.isRidingHorse())
-            {
-                this.renderHorseJumpBar(k);
-            }
-            else if (this.mc.playerController.gameIsSurvivalOrAdventure())
-            {
-                this.renderExpBar(k);
-            }
-
-            if (this.mc.gameSettings.heldItemTooltips && this.mc.playerController.getCurrentGameType() != GameType.SPECTATOR)
-            {
-                this.renderSelectedItem();
-            }
-            else if (this.mc.player.isSpectator())
-            {
-                this.spectatorGui.renderSelectedItem();
-            }
-        }
-
-        if (this.mc.player.getSleepTimer() > 0)
-        {
-            this.mc.profiler.startSection("sleep");
-            GlStateManager.disableDepthTest();
-            GlStateManager.disableAlphaTest();
-            float f2 = (float)this.mc.player.getSleepTimer();
-            float f1 = f2 / 100.0F;
-
-            if (f1 > 1.0F)
-            {
-                f1 = 1.0F - (f2 - 100.0F) / 10.0F;
-            }
-
-            int i = (int)(220.0F * f1) << 24 | 1052704;
-            drawRect(0, 0, this.scaledWidth, this.scaledHeight, i);
-            GlStateManager.enableAlphaTest();
-            GlStateManager.enableDepthTest();
-            this.mc.profiler.endSection();
-            GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
-        }
-
-        if (this.mc.isDemo())
-        {
-            this.renderDemoOverlay();
-        }
-
-        this.renderPotionEffects();
-
-        if (this.mc.gameSettings.showDebugInfo)
-        {
-            this.overlayDebug.render();
-        }
-
-        if (!this.mc.gameSettings.hideGUI)
-        {
-            if (this.overlayMessageTime > 0)
-            {
-                this.mc.profiler.startSection("overlayMessage");
-                float f3 = (float)this.overlayMessageTime - partialTicks;
-                int l = (int)(f3 * 255.0F / 20.0F);
-
-                if (l > 255)
-                {
-                    l = 255;
-                }
-
-                if (l > 8)
-                {
-                    GlStateManager.pushMatrix();
-                    GlStateManager.translatef((float)(this.scaledWidth / 2), (float)(this.scaledHeight - 68), 0.0F);
-                    GlStateManager.enableBlend();
-                    GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-                    int j1 = 16777215;
-
-                    if (this.animateOverlayMessageColor)
-                    {
-                        j1 = MathHelper.hsvToRGB(f3 / 50.0F, 0.7F, 0.6F) & 16777215;
-                    }
-
-                    fontrenderer.drawString(this.overlayMessage, (float)(-fontrenderer.getStringWidth(this.overlayMessage) / 2), -4.0F, j1 + (l << 24 & -16777216));
-                    GlStateManager.disableBlend();
-                    GlStateManager.popMatrix();
-                }
-
-                this.mc.profiler.endSection();
-            }
-
-            if (this.titlesTimer > 0)
-            {
-                this.mc.profiler.startSection("titleAndSubtitle");
-                float f4 = (float)this.titlesTimer - partialTicks;
-                int i1 = 255;
-
-                if (this.titlesTimer > this.titleFadeOut + this.titleDisplayTime)
-                {
-                    float f5 = (float)(this.titleFadeIn + this.titleDisplayTime + this.titleFadeOut) - f4;
-                    i1 = (int)(f5 * 255.0F / (float)this.titleFadeIn);
-                }
-
-                if (this.titlesTimer <= this.titleFadeOut)
-                {
-                    i1 = (int)(f4 * 255.0F / (float)this.titleFadeOut);
-                }
-
-                i1 = MathHelper.clamp(i1, 0, 255);
-
-                if (i1 > 8)
-                {
-                    GlStateManager.pushMatrix();
-                    GlStateManager.translatef((float)(this.scaledWidth / 2), (float)(this.scaledHeight / 2), 0.0F);
-                    GlStateManager.enableBlend();
-                    GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-                    GlStateManager.pushMatrix();
-                    GlStateManager.scalef(4.0F, 4.0F, 4.0F);
-                    int k1 = i1 << 24 & -16777216;
-                    fontrenderer.drawStringWithShadow(this.displayedTitle, (float)(-fontrenderer.getStringWidth(this.displayedTitle) / 2), -10.0F, 16777215 | k1);
-                    GlStateManager.popMatrix();
-                    GlStateManager.pushMatrix();
-                    GlStateManager.scalef(2.0F, 2.0F, 2.0F);
-                    fontrenderer.drawStringWithShadow(this.displayedSubTitle, (float)(-fontrenderer.getStringWidth(this.displayedSubTitle) / 2), 5.0F, 16777215 | k1);
-                    GlStateManager.popMatrix();
-                    GlStateManager.disableBlend();
-                    GlStateManager.popMatrix();
-                }
-
-                this.mc.profiler.endSection();
-            }
-
-            this.overlaySubtitle.render();
-            Scoreboard scoreboard = this.mc.world.getScoreboard();
-            ScoreObjective scoreobjective = null;
-            ScorePlayerTeam scoreplayerteam = scoreboard.getPlayersTeam(this.mc.player.getScoreboardName());
-
-            if (scoreplayerteam != null)
-            {
-                int j = scoreplayerteam.getColor().getColorIndex();
-
-                if (j >= 0)
-                {
-                    scoreobjective = scoreboard.getObjectiveInDisplaySlot(3 + j);
-                }
-            }
-
-            ScoreObjective scoreobjective1 = scoreobjective != null ? scoreobjective : scoreboard.getObjectiveInDisplaySlot(1);
-
-            if (scoreobjective1 != null)
-            {
-                this.renderScoreboard(scoreobjective1);
-            }
-
-            GlStateManager.enableBlend();
-            GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-            GlStateManager.disableAlphaTest();
-            GlStateManager.pushMatrix();
-            GlStateManager.translatef(0.0F, (float)(this.scaledHeight - 48), 0.0F);
-            this.mc.profiler.startSection("chat");
-            this.persistantChatGUI.drawChat(this.ticks);
-            this.mc.profiler.endSection();
-            GlStateManager.popMatrix();
-            scoreobjective1 = scoreboard.getObjectiveInDisplaySlot(0);
-
-            if (this.mc.gameSettings.keyBindPlayerList.isKeyDown() && (!this.mc.isIntegratedServerRunning() || this.mc.player.connection.getPlayerInfoMap().size() > 1 || scoreobjective1 != null))
-            {
-                this.overlayPlayerList.setVisible(true);
-                this.overlayPlayerList.renderPlayerlist(this.scaledWidth, scoreboard, scoreobjective1);
-            }
-            else
-            {
-                this.overlayPlayerList.setVisible(false);
-            }
-        }
-
-        GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
-        GlStateManager.disableLighting();
-        GlStateManager.enableAlphaTest();
-    }
-
-    private void renderAttackIndicator(float partialTicks)
-    {
-        GameSettings gamesettings = this.mc.gameSettings;
-
-        if (gamesettings.thirdPersonView == 0)
-        {
-            if (this.mc.playerController.getCurrentGameType() == GameType.SPECTATOR && this.mc.pointedEntity == null)
-            {
-                RayTraceResult raytraceresult = this.mc.objectMouseOver;
-
-                if (raytraceresult == null || raytraceresult.type != RayTraceResult.Type.BLOCK)
-                {
-                    return;
-                }
-
-                BlockPos blockpos = raytraceresult.getBlockPos();
-                IBlockState iblockstate = this.mc.world.getBlockState(blockpos);
-
-                if (!ReflectorForge.blockHasTileEntity(iblockstate) || !(this.mc.world.getTileEntity(blockpos) instanceof IInventory))
-                {
-                    return;
-                }
-            }
-
-            if (gamesettings.showDebugInfo && !gamesettings.hideGUI && !this.mc.player.hasReducedDebug() && !gamesettings.reducedDebugInfo)
-            {
-                GlStateManager.pushMatrix();
-                GlStateManager.translatef((float)(this.scaledWidth / 2), (float)(this.scaledHeight / 2), this.zLevel);
-                Entity entity = this.mc.getRenderViewEntity();
-                GlStateManager.rotatef(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks, -1.0F, 0.0F, 0.0F);
-                GlStateManager.rotatef(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks, 0.0F, 1.0F, 0.0F);
-                GlStateManager.scalef(-1.0F, -1.0F, -1.0F);
-                OpenGlHelper.renderDirections(10);
-                GlStateManager.popMatrix();
-            }
-            else
-            {
-                GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.ONE_MINUS_DST_COLOR, GlStateManager.DestFactor.ONE_MINUS_SRC_COLOR, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-                int l = 15;
-                this.drawTexturedModalRect((float)this.scaledWidth / 2.0F - 7.5F, (float)this.scaledHeight / 2.0F - 7.5F, 0, 0, 15, 15);
-
-                if (this.mc.gameSettings.attackIndicator == 1)
-                {
-                    float f = this.mc.player.getCooledAttackStrength(0.0F);
-                    boolean flag = false;
-
-                    if (this.mc.pointedEntity != null && this.mc.pointedEntity instanceof EntityLivingBase && f >= 1.0F)
-                    {
-                        flag = this.mc.player.getCooldownPeriod() > 5.0F;
-                        flag = flag & this.mc.pointedEntity.isEntityAlive();
-                    }
-
-                    int i = this.scaledHeight / 2 - 7 + 16;
-                    int j = this.scaledWidth / 2 - 8;
-
-                    if (flag)
-                    {
-                        this.drawTexturedModalRect(j, i, 68, 94, 16, 16);
-                    }
-                    else if (f < 1.0F)
-                    {
-                        int k = (int)(f * 17.0F);
-                        this.drawTexturedModalRect(j, i, 36, 94, 16, 4);
-                        this.drawTexturedModalRect(j, i, 52, 94, k, 4);
-                    }
-                }
-            }
-        }
-    }
-
-    protected void renderPotionEffects()
-    {
-        Collection<PotionEffect> collection = this.mc.player.getActivePotionEffects();
-
-        if (!collection.isEmpty())
-        {
-            this.mc.getTextureManager().bindTexture(GuiContainer.INVENTORY_BACKGROUND);
-            GlStateManager.enableBlend();
-            int i = 0;
-            int j = 0;
-            Iterator iterator = Ordering.natural().reverse().sortedCopy(collection).iterator();
-
-            while (true)
-            {
-                PotionEffect potioneffect;
-                Potion potion;
-                boolean flag;
-
-                while (true)
-                {
-                    if (!iterator.hasNext())
-                    {
-                        return;
-                    }
-
-                    potioneffect = (PotionEffect)iterator.next();
-                    potion = potioneffect.getPotion();
-                    flag = potion.hasStatusIcon();
-
-                    if (!Reflector.ForgePotion_shouldRenderHUD.exists())
-                    {
-                        break;
-                    }
-
-                    if (Reflector.callBoolean(potion, Reflector.ForgePotion_shouldRenderHUD, potioneffect))
-                    {
-                        this.mc.getTextureManager().bindTexture(GuiContainer.INVENTORY_BACKGROUND);
-                        flag = true;
-                        break;
-                    }
-                }
-
-                if (flag && potioneffect.isShowIcon())
-                {
-                    int k = this.scaledWidth;
-                    int l = 1;
-
-                    if (this.mc.isDemo())
-                    {
-                        l += 15;
-                    }
-
-                    int i1 = potion.getStatusIconIndex();
-
-                    if (potion.isBeneficial())
-                    {
-                        ++i;
-                        k = k - 25 * i;
-                    }
-                    else
-                    {
-                        ++j;
-                        k = k - 25 * j;
-                        l += 26;
-                    }
-
-                    GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
-                    float f = 1.0F;
-
-                    if (potioneffect.isAmbient())
-                    {
-                        this.drawTexturedModalRect(k, l, 165, 166, 24, 24);
-                    }
-                    else
-                    {
-                        this.drawTexturedModalRect(k, l, 141, 166, 24, 24);
-
-                        if (potioneffect.getDuration() <= 200)
-                        {
-                            int j1 = 10 - potioneffect.getDuration() / 20;
-                            f = MathHelper.clamp((float)potioneffect.getDuration() / 10.0F / 5.0F * 0.5F, 0.0F, 0.5F) + MathHelper.cos((float)potioneffect.getDuration() * (float)Math.PI / 5.0F) * MathHelper.clamp((float)j1 / 10.0F * 0.25F, 0.0F, 0.25F);
-                        }
-                    }
-
-                    GlStateManager.color4f(1.0F, 1.0F, 1.0F, f);
-
-                    if (Reflector.ForgePotion_renderHUDEffect.exists())
-                    {
-                        if (potion.hasStatusIcon())
-                        {
-                            this.drawTexturedModalRect(k + 3, l + 3, i1 % 8 * 18, 198 + i1 / 8 * 18, 18, 18);
-                        }
-
-                        Reflector.call(potion, Reflector.ForgePotion_renderHUDEffect, k, l, potioneffect, this.mc, f);
-                    }
-                    else
-                    {
-                        int l1 = i1 % 12;
-                        int k1 = i1 / 12;
-                        this.drawTexturedModalRect(k + 3, l + 3, l1 * 18, 198 + k1 * 18, 18, 18);
-                    }
-                }
-            }
-        }
-    }
-
-    protected void renderHotbar(float partialTicks)
-    {
-        EntityPlayer entityplayer = this.getRenderViewPlayer();
-
-        if (entityplayer != null)
-        {
-            GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
-            this.mc.getTextureManager().bindTexture(WIDGETS_TEX_PATH);
-            ItemStack itemstack = entityplayer.getHeldItemOffhand();
-            EnumHandSide enumhandside = entityplayer.getPrimaryHand().opposite();
-            int i = this.scaledWidth / 2;
-            float f = this.zLevel;
-            int j = 182;
-            int k = 91;
-            this.zLevel = -90.0F;
-            this.drawTexturedModalRect(i - 91, this.scaledHeight - 22, 0, 0, 182, 22);
-            this.drawTexturedModalRect(i - 91 - 1 + entityplayer.inventory.currentItem * 20, this.scaledHeight - 22 - 1, 0, 22, 24, 22);
-
-            if (!itemstack.isEmpty())
-            {
-                if (enumhandside == EnumHandSide.LEFT)
-                {
-                    this.drawTexturedModalRect(i - 91 - 29, this.scaledHeight - 23, 24, 22, 29, 24);
-                }
-                else
-                {
-                    this.drawTexturedModalRect(i + 91, this.scaledHeight - 23, 53, 22, 29, 24);
-                }
-            }
-
-            this.zLevel = f;
-            GlStateManager.enableRescaleNormal();
-            GlStateManager.enableBlend();
-            GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-            RenderHelper.enableGUIStandardItemLighting();
-            CustomItems.setRenderOffHand(false);
-
-            for (int l = 0; l < 9; ++l)
-            {
-                int i1 = i - 90 + l * 20 + 2;
-                int j1 = this.scaledHeight - 16 - 3;
-                this.renderHotbarItem(i1, j1, partialTicks, entityplayer, entityplayer.inventory.mainInventory.get(l));
-            }
-
-            if (!itemstack.isEmpty())
-            {
-                CustomItems.setRenderOffHand(true);
-                int l1 = this.scaledHeight - 16 - 3;
-
-                if (enumhandside == EnumHandSide.LEFT)
-                {
-                    this.renderHotbarItem(i - 91 - 26, l1, partialTicks, entityplayer, itemstack);
-                }
-                else
-                {
-                    this.renderHotbarItem(i + 91 + 10, l1, partialTicks, entityplayer, itemstack);
-                }
-
-                CustomItems.setRenderOffHand(false);
-            }
-
-            if (this.mc.gameSettings.attackIndicator == 2)
-            {
-                float f1 = this.mc.player.getCooledAttackStrength(0.0F);
-
-                if (f1 < 1.0F)
-                {
-                    int i2 = this.scaledHeight - 20;
-                    int j2 = i + 91 + 6;
-
-                    if (enumhandside == EnumHandSide.RIGHT)
-                    {
-                        j2 = i - 91 - 22;
-                    }
-
-                    this.mc.getTextureManager().bindTexture(Gui.ICONS);
-                    int k1 = (int)(f1 * 19.0F);
-                    GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
-                    this.drawTexturedModalRect(j2, i2, 0, 94, 18, 18);
-                    this.drawTexturedModalRect(j2, i2 + 18 - k1, 18, 112 - k1, 18, k1);
-                }
-            }
-
-            RenderHelper.disableStandardItemLighting();
-            GlStateManager.disableRescaleNormal();
-            GlStateManager.disableBlend();
-        }
-    }
-
-    public void renderHorseJumpBar(int x)
-    {
-        this.mc.profiler.startSection("jumpBar");
-        this.mc.getTextureManager().bindTexture(Gui.ICONS);
-        float f = this.mc.player.getHorseJumpPower();
-        int i = 182;
-        int j = (int)(f * 183.0F);
-        int k = this.scaledHeight - 32 + 3;
-        this.drawTexturedModalRect(x, k, 0, 84, 182, 5);
-
-        if (j > 0)
-        {
-            this.drawTexturedModalRect(x, k, 0, 89, j, 5);
-        }
-
-        this.mc.profiler.endSection();
-    }
-
-    public void renderExpBar(int x)
-    {
-        this.mc.profiler.startSection("expBar");
-        this.mc.getTextureManager().bindTexture(Gui.ICONS);
-        int i = this.mc.player.xpBarCap();
-
-        if (i > 0)
-        {
-            int j = 182;
-            int k = (int)(this.mc.player.experience * 183.0F);
-            int l = this.scaledHeight - 32 + 3;
-            this.drawTexturedModalRect(x, l, 0, 64, 182, 5);
-
-            if (k > 0)
-            {
-                this.drawTexturedModalRect(x, l, 0, 69, k, 5);
-            }
-        }
-
-        this.mc.profiler.endSection();
-
-        if (this.mc.player.experienceLevel > 0)
-        {
-            this.mc.profiler.startSection("expLevel");
-            int j1 = 8453920;
-
-            if (Config.isCustomColors())
-            {
-                j1 = CustomColors.getExpBarTextColor(j1);
-            }
-
-            String s = "" + this.mc.player.experienceLevel;
-            int k1 = (this.scaledWidth - this.getFontRenderer().getStringWidth(s)) / 2;
-            int i1 = this.scaledHeight - 31 - 4;
-            this.getFontRenderer().drawString(s, (float)(k1 + 1), (float)i1, 0);
-            this.getFontRenderer().drawString(s, (float)(k1 - 1), (float)i1, 0);
-            this.getFontRenderer().drawString(s, (float)k1, (float)(i1 + 1), 0);
-            this.getFontRenderer().drawString(s, (float)k1, (float)(i1 - 1), 0);
-            this.getFontRenderer().drawString(s, (float)k1, (float)i1, j1);
-            this.mc.profiler.endSection();
-        }
-    }
-
-    public void renderSelectedItem()
-    {
-        this.mc.profiler.startSection("selectedItemName");
-
-        if (this.remainingHighlightTicks > 0 && !this.highlightingItemStack.isEmpty())
-        {
-            ITextComponent itextcomponent = (new TextComponentString("")).appendSibling(this.highlightingItemStack.getDisplayName()).applyTextStyle(this.highlightingItemStack.getRarity().color);
-
-            if (this.highlightingItemStack.hasDisplayName())
-            {
-                itextcomponent.applyTextStyle(TextFormatting.ITALIC);
-            }
-
-            String s = itextcomponent.getFormattedText();
-            int i = (this.scaledWidth - this.getFontRenderer().getStringWidth(s)) / 2;
-            int j = this.scaledHeight - 59;
-
-            if (!this.mc.playerController.shouldDrawHUD())
-            {
-                j += 14;
-            }
-
-            int k = (int)((float)this.remainingHighlightTicks * 256.0F / 10.0F);
-
-            if (k > 255)
-            {
-                k = 255;
-            }
-
-            if (k > 0)
-            {
-                GlStateManager.pushMatrix();
-                GlStateManager.enableBlend();
-                GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-                this.getFontRenderer().drawStringWithShadow(s, (float)i, (float)j, 16777215 + (k << 24));
-                GlStateManager.disableBlend();
-                GlStateManager.popMatrix();
-            }
-        }
-
-        this.mc.profiler.endSection();
-    }
-
-    public void renderDemoOverlay()
-    {
-        this.mc.profiler.startSection("demo");
-        String s;
-
-        if (this.mc.world.getGameTime() >= 120500L)
-        {
-            s = I18n.format("demo.demoExpired");
-        }
-        else
-        {
-            s = I18n.format("demo.remainingTime", StringUtils.ticksToElapsedTime((int)(120500L - this.mc.world.getGameTime())));
-        }
-
-        int i = this.getFontRenderer().getStringWidth(s);
-        this.getFontRenderer().drawStringWithShadow(s, (float)(this.scaledWidth - i - 10), 5.0F, 16777215);
-        this.mc.profiler.endSection();
-    }
-
-    private void renderScoreboard(ScoreObjective objective)
-    {
-        Scoreboard scoreboard = objective.getScoreboard();
-        Collection<Score> collection = scoreboard.getSortedScores(objective);
-        List<Score> list = (List)collection.stream().filter((p_lambda$renderScoreboard$0_0_) ->
-        {
-            return p_lambda$renderScoreboard$0_0_.getPlayerName() != null && !p_lambda$renderScoreboard$0_0_.getPlayerName().startsWith("#");
-        }).collect(Collectors.toList());
-
-        if (list.size() > 15)
-        {
-            collection = Lists.newArrayList(Iterables.skip(list, collection.size() - 15));
-        }
-        else
-        {
-            collection = list;
-        }
-
-        String s = objective.getDisplayName().getFormattedText();
-        int i = this.getFontRenderer().getStringWidth(s);
-        int j = i;
-
-        for (Score score : collection)
-        {
-            ScorePlayerTeam scoreplayerteam = scoreboard.getPlayersTeam(score.getPlayerName());
-            String s1 = ScorePlayerTeam.formatMemberName(scoreplayerteam, new TextComponentString(score.getPlayerName())).getFormattedText() + ": " + TextFormatting.RED + score.getScorePoints();
-            j = Math.max(j, this.getFontRenderer().getStringWidth(s1));
-        }
-
-        int j1 = collection.size() * this.getFontRenderer().FONT_HEIGHT;
-        int k1 = this.scaledHeight / 2 + j1 / 3;
-        int l1 = 3;
-        int i2 = this.scaledWidth - j - 3;
-        int k = 0;
-
-        for (Score score1 : collection)
-        {
-            ++k;
-            ScorePlayerTeam scoreplayerteam1 = scoreboard.getPlayersTeam(score1.getPlayerName());
-            String s2 = ScorePlayerTeam.formatMemberName(scoreplayerteam1, new TextComponentString(score1.getPlayerName())).getFormattedText();
-            String s3 = TextFormatting.RED + "" + score1.getScorePoints();
-            int l = k1 - k * this.getFontRenderer().FONT_HEIGHT;
-            int i1 = this.scaledWidth - 3 + 2;
-            drawRect(i2 - 2, l, i1, l + this.getFontRenderer().FONT_HEIGHT, 1342177280);
-            this.getFontRenderer().drawString(s2, (float)i2, (float)l, 553648127);
-            this.getFontRenderer().drawString(s3, (float)(i1 - this.getFontRenderer().getStringWidth(s3)), (float)l, 553648127);
-
-            if (k == collection.size())
-            {
-                drawRect(i2 - 2, l - this.getFontRenderer().FONT_HEIGHT - 1, i1, l - 1, 1610612736);
-                drawRect(i2 - 2, l - 1, i1, l, 1342177280);
-                this.getFontRenderer().drawString(s, (float)(i2 + j / 2 - i / 2), (float)(l - this.getFontRenderer().FONT_HEIGHT), 553648127);
-            }
-        }
-    }
-
-    private EntityPlayer getRenderViewPlayer()
-    {
-        return !(this.mc.getRenderViewEntity() instanceof EntityPlayer) ? null : (EntityPlayer)this.mc.getRenderViewEntity();
-    }
-
-    private EntityLivingBase getMountEntity()
-    {
-        EntityPlayer entityplayer = this.getRenderViewPlayer();
-
-        if (entityplayer != null)
-        {
-            Entity entity = entityplayer.getRidingEntity();
-
-            if (entity == null)
-            {
-                return null;
-            }
-
-            if (entity instanceof EntityLivingBase)
-            {
-                return (EntityLivingBase)entity;
-            }
-        }
-
-        return null;
-    }
-
-    private int getRenderMountHealth(EntityLivingBase p_502210_1_)
-    {
-        if (p_502210_1_ != null && p_502210_1_.isLiving())
-        {
-            float f = p_502210_1_.getMaxHealth();
-            int i = (int)(f + 0.5F) / 2;
-
-            if (i > 30)
-            {
-                i = 30;
-            }
-
-            return i;
-        }
-        else
-        {
-            return 0;
-        }
-    }
-
-    private int func_502211_c(int p_502211_1_)
-    {
-        return (int)Math.ceil((double)p_502211_1_ / 10.0D);
-    }
-
-    private void renderPlayerStats()
-    {
-        EntityPlayer entityplayer = this.getRenderViewPlayer();
-
-        if (entityplayer != null)
-        {
-            int i = MathHelper.ceil(entityplayer.getHealth());
-            boolean flag = this.healthUpdateCounter > (long)this.ticks && (this.healthUpdateCounter - (long)this.ticks) / 3L % 2L == 1L;
-            long j = Util.milliTime();
-
-            if (i < this.playerHealth && entityplayer.hurtResistantTime > 0)
-            {
-                this.lastSystemTime = j;
-                this.healthUpdateCounter = (long)(this.ticks + 20);
-            }
-            else if (i > this.playerHealth && entityplayer.hurtResistantTime > 0)
-            {
-                this.lastSystemTime = j;
-                this.healthUpdateCounter = (long)(this.ticks + 10);
-            }
-
-            if (j - this.lastSystemTime > 1000L)
-            {
-                this.playerHealth = i;
-                this.lastPlayerHealth = i;
-                this.lastSystemTime = j;
-            }
-
-            this.playerHealth = i;
-            int k = this.lastPlayerHealth;
-            this.rand.setSeed((long)(this.ticks * 312871));
-            FoodStats foodstats = entityplayer.getFoodStats();
-            int l = foodstats.getFoodLevel();
-            IAttributeInstance iattributeinstance = entityplayer.getAttribute(SharedMonsterAttributes.MAX_HEALTH);
-            int i1 = this.scaledWidth / 2 - 91;
-            int j1 = this.scaledWidth / 2 + 91;
-            int k1 = this.scaledHeight - 39;
-            float f = (float)iattributeinstance.getValue();
-            int l1 = MathHelper.ceil(entityplayer.getAbsorptionAmount());
-            int i2 = MathHelper.ceil((f + (float)l1) / 2.0F / 10.0F);
-            int j2 = Math.max(10 - (i2 - 2), 3);
-            int k2 = k1 - (i2 - 1) * j2 - 10;
-            int l2 = k1 - 10;
-            int i3 = l1;
-            int j3 = entityplayer.getTotalArmorValue();
-            int k3 = -1;
-
-            if (entityplayer.isPotionActive(MobEffects.REGENERATION))
-            {
-                k3 = this.ticks % MathHelper.ceil(f + 5.0F);
-            }
-
-            this.mc.profiler.startSection("armor");
-
-            for (int l3 = 0; l3 < 10; ++l3)
-            {
-                if (j3 > 0)
-                {
-                    int i4 = i1 + l3 * 8;
-
-                    if (l3 * 2 + 1 < j3)
-                    {
-                        this.drawTexturedModalRect(i4, k2, 34, 9, 9, 9);
-                    }
-
-                    if (l3 * 2 + 1 == j3)
-                    {
-                        this.drawTexturedModalRect(i4, k2, 25, 9, 9, 9);
-                    }
-
-                    if (l3 * 2 + 1 > j3)
-                    {
-                        this.drawTexturedModalRect(i4, k2, 16, 9, 9, 9);
-                    }
-                }
-            }
-
-            this.mc.profiler.endStartSection("health");
-
-            for (int l5 = MathHelper.ceil((f + (float)l1) / 2.0F) - 1; l5 >= 0; --l5)
-            {
-                int i6 = 16;
-
-                if (entityplayer.isPotionActive(MobEffects.POISON))
-                {
-                    i6 += 36;
-                }
-                else if (entityplayer.isPotionActive(MobEffects.WITHER))
-                {
-                    i6 += 72;
-                }
-
-                int j4 = 0;
-
-                if (flag)
-                {
-                    j4 = 1;
-                }
-
-                int k4 = MathHelper.ceil((float)(l5 + 1) / 10.0F) - 1;
-                int l4 = i1 + l5 % 10 * 8;
-                int i5 = k1 - k4 * j2;
-
-                if (i <= 4)
-                {
-                    i5 += this.rand.nextInt(2);
-                }
-
-                if (i3 <= 0 && l5 == k3)
-                {
-                    i5 -= 2;
-                }
-
-                int j5 = 0;
-
-                if (entityplayer.world.getWorldInfo().isHardcoreModeEnabled())
-                {
-                    j5 = 5;
-                }
-
-                this.drawTexturedModalRect(l4, i5, 16 + j4 * 9, 9 * j5, 9, 9);
-
-                if (flag)
-                {
-                    if (l5 * 2 + 1 < k)
-                    {
-                        this.drawTexturedModalRect(l4, i5, i6 + 54, 9 * j5, 9, 9);
-                    }
-
-                    if (l5 * 2 + 1 == k)
-                    {
-                        this.drawTexturedModalRect(l4, i5, i6 + 63, 9 * j5, 9, 9);
-                    }
-                }
-
-                if (i3 > 0)
-                {
-                    if (i3 == l1 && l1 % 2 == 1)
-                    {
-                        this.drawTexturedModalRect(l4, i5, i6 + 153, 9 * j5, 9, 9);
-                        --i3;
-                    }
-                    else
-                    {
-                        this.drawTexturedModalRect(l4, i5, i6 + 144, 9 * j5, 9, 9);
-                        i3 -= 2;
-                    }
-                }
-                else
-                {
-                    if (l5 * 2 + 1 < i)
-                    {
-                        this.drawTexturedModalRect(l4, i5, i6 + 36, 9 * j5, 9, 9);
-                    }
-
-                    if (l5 * 2 + 1 == i)
-                    {
-                        this.drawTexturedModalRect(l4, i5, i6 + 45, 9 * j5, 9, 9);
-                    }
-                }
-            }
-
-            EntityLivingBase entitylivingbase = this.getMountEntity();
-            int j6 = this.getRenderMountHealth(entitylivingbase);
-
-            if (j6 == 0)
-            {
-                this.mc.profiler.endStartSection("food");
-
-                for (int k6 = 0; k6 < 10; ++k6)
-                {
-                    int i7 = k1;
-                    int k7 = 16;
-                    int i8 = 0;
-
-                    if (entityplayer.isPotionActive(MobEffects.HUNGER))
-                    {
-                        k7 += 36;
-                        i8 = 13;
-                    }
-
-                    if (entityplayer.getFoodStats().getSaturationLevel() <= 0.0F && this.ticks % (l * 3 + 1) == 0)
-                    {
-                        i7 = k1 + (this.rand.nextInt(3) - 1);
-                    }
-
-                    int k8 = j1 - k6 * 8 - 9;
-                    this.drawTexturedModalRect(k8, i7, 16 + i8 * 9, 27, 9, 9);
-
-                    if (k6 * 2 + 1 < l)
-                    {
-                        this.drawTexturedModalRect(k8, i7, k7 + 36, 27, 9, 9);
-                    }
-
-                    if (k6 * 2 + 1 == l)
-                    {
-                        this.drawTexturedModalRect(k8, i7, k7 + 45, 27, 9, 9);
-                    }
-                }
-
-                l2 -= 10;
-            }
-
-            this.mc.profiler.endStartSection("air");
-            int l6 = entityplayer.getAir();
-            int j7 = entityplayer.getMaxAir();
-
-            if (entityplayer.areEyesInFluid(FluidTags.WATER) || l6 < j7)
-            {
-                int l7 = this.func_502211_c(j6) - 1;
-                l2 = l2 - l7 * 10;
-                int j8 = MathHelper.ceil((double)(l6 - 2) * 10.0D / (double)j7);
-                int l8 = MathHelper.ceil((double)l6 * 10.0D / (double)j7) - j8;
-
-                for (int k5 = 0; k5 < j8 + l8; ++k5)
-                {
-                    if (k5 < j8)
-                    {
-                        this.drawTexturedModalRect(j1 - k5 * 8 - 9, l2, 16, 18, 9, 9);
-                    }
-                    else
-                    {
-                        this.drawTexturedModalRect(j1 - k5 * 8 - 9, l2, 25, 18, 9, 9);
-                    }
-                }
-            }
-
-            this.mc.profiler.endSection();
-        }
-    }
-
-    private void renderVehicleHealth()
-    {
-        EntityLivingBase entitylivingbase = this.getMountEntity();
-
-        if (entitylivingbase != null)
-        {
-            int i = this.getRenderMountHealth(entitylivingbase);
-
-            if (i != 0)
-            {
-                int j = (int)Math.ceil((double)entitylivingbase.getHealth());
-                this.mc.profiler.endStartSection("mountHealth");
-                int k = this.scaledHeight - 39;
-                int l = this.scaledWidth / 2 + 91;
-                int i1 = k;
-                int j1 = 0;
-
-                for (boolean flag = false; i > 0; j1 += 20)
-                {
-                    int k1 = Math.min(i, 10);
-                    i -= k1;
-
-                    for (int l1 = 0; l1 < k1; ++l1)
-                    {
-                        int i2 = 52;
-                        int j2 = 0;
-                        int k2 = l - l1 * 8 - 9;
-                        this.drawTexturedModalRect(k2, i1, 52 + j2 * 9, 9, 9, 9);
-
-                        if (l1 * 2 + 1 + j1 < j)
-                        {
-                            this.drawTexturedModalRect(k2, i1, 88, 9, 9, 9);
-                        }
-
-                        if (l1 * 2 + 1 + j1 == j)
-                        {
-                            this.drawTexturedModalRect(k2, i1, 97, 9, 9, 9);
-                        }
-                    }
-
-                    i1 -= 10;
-                }
-            }
-        }
-    }
-
-    private void renderPumpkinOverlay()
-    {
-        GlStateManager.disableDepthTest();
-        GlStateManager.depthMask(false);
-        GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-        GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
-        GlStateManager.disableAlphaTest();
-        this.mc.getTextureManager().bindTexture(PUMPKIN_BLUR_TEX_PATH);
-        Tessellator tessellator = Tessellator.getInstance();
-        BufferBuilder bufferbuilder = tessellator.getBuffer();
-        bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
-        bufferbuilder.pos(0.0D, (double)this.scaledHeight, -90.0D).tex(0.0D, 1.0D).endVertex();
-        bufferbuilder.pos((double)this.scaledWidth, (double)this.scaledHeight, -90.0D).tex(1.0D, 1.0D).endVertex();
-        bufferbuilder.pos((double)this.scaledWidth, 0.0D, -90.0D).tex(1.0D, 0.0D).endVertex();
-        bufferbuilder.pos(0.0D, 0.0D, -90.0D).tex(0.0D, 0.0D).endVertex();
-        tessellator.draw();
-        GlStateManager.depthMask(true);
-        GlStateManager.enableDepthTest();
-        GlStateManager.enableAlphaTest();
-        GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
-    }
-
-    private void updateVignetteBrightness(Entity entityIn)
-    {
-        if (entityIn != null)
-        {
-            float f = MathHelper.clamp(1.0F - entityIn.getBrightness(), 0.0F, 1.0F);
-            this.prevVignetteBrightness = (float)((double)this.prevVignetteBrightness + (double)(f - this.prevVignetteBrightness) * 0.01D);
-        }
-    }
-
-    private void renderVignette(Entity entityIn)
-    {
-        if (!Config.isVignetteEnabled())
-        {
-            GlStateManager.enableDepthTest();
-            GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-        }
-        else
-        {
-            WorldBorder worldborder = this.mc.world.getWorldBorder();
-            float f = (float)worldborder.getClosestDistance(entityIn);
-            double d0 = Math.min(worldborder.getResizeSpeed() * (double)worldborder.getWarningTime() * 1000.0D, Math.abs(worldborder.getTargetSize() - worldborder.getDiameter()));
-            double d1 = Math.max((double)worldborder.getWarningDistance(), d0);
-
-            if ((double)f < d1)
-            {
-                f = 1.0F - (float)((double)f / d1);
-            }
-            else
-            {
-                f = 0.0F;
-            }
-
-            GlStateManager.disableDepthTest();
-            GlStateManager.depthMask(false);
-            GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.ZERO, GlStateManager.DestFactor.ONE_MINUS_SRC_COLOR, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-
-            if (f > 0.0F)
-            {
-                GlStateManager.color4f(0.0F, f, f, 1.0F);
-            }
-            else
-            {
-                GlStateManager.color4f(this.prevVignetteBrightness, this.prevVignetteBrightness, this.prevVignetteBrightness, 1.0F);
-            }
-
-            this.mc.getTextureManager().bindTexture(VIGNETTE_TEX_PATH);
-            Tessellator tessellator = Tessellator.getInstance();
-            BufferBuilder bufferbuilder = tessellator.getBuffer();
-            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
-            bufferbuilder.pos(0.0D, (double)this.scaledHeight, -90.0D).tex(0.0D, 1.0D).endVertex();
-            bufferbuilder.pos((double)this.scaledWidth, (double)this.scaledHeight, -90.0D).tex(1.0D, 1.0D).endVertex();
-            bufferbuilder.pos((double)this.scaledWidth, 0.0D, -90.0D).tex(1.0D, 0.0D).endVertex();
-            bufferbuilder.pos(0.0D, 0.0D, -90.0D).tex(0.0D, 0.0D).endVertex();
-            tessellator.draw();
-            GlStateManager.depthMask(true);
-            GlStateManager.enableDepthTest();
-            GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
-            GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-        }
-    }
-
-    private void renderPortal(float timeInPortal)
-    {
-        if (timeInPortal < 1.0F)
-        {
-            timeInPortal = timeInPortal * timeInPortal;
-            timeInPortal = timeInPortal * timeInPortal;
-            timeInPortal = timeInPortal * 0.8F + 0.2F;
-        }
-
-        GlStateManager.disableAlphaTest();
-        GlStateManager.disableDepthTest();
-        GlStateManager.depthMask(false);
-        GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-        GlStateManager.color4f(1.0F, 1.0F, 1.0F, timeInPortal);
-        this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
-        TextureAtlasSprite textureatlassprite = this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(Blocks.NETHER_PORTAL.getDefaultState());
-        float f = textureatlassprite.getMinU();
-        float f1 = textureatlassprite.getMinV();
-        float f2 = textureatlassprite.getMaxU();
-        float f3 = textureatlassprite.getMaxV();
-        Tessellator tessellator = Tessellator.getInstance();
-        BufferBuilder bufferbuilder = tessellator.getBuffer();
-        bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
-        bufferbuilder.pos(0.0D, (double)this.scaledHeight, -90.0D).tex((double)f, (double)f3).endVertex();
-        bufferbuilder.pos((double)this.scaledWidth, (double)this.scaledHeight, -90.0D).tex((double)f2, (double)f3).endVertex();
-        bufferbuilder.pos((double)this.scaledWidth, 0.0D, -90.0D).tex((double)f2, (double)f1).endVertex();
-        bufferbuilder.pos(0.0D, 0.0D, -90.0D).tex((double)f, (double)f1).endVertex();
-        tessellator.draw();
-        GlStateManager.depthMask(true);
-        GlStateManager.enableDepthTest();
-        GlStateManager.enableAlphaTest();
-        GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
-    }
-
-    private void renderHotbarItem(int x, int y, float partialTicks, EntityPlayer player, ItemStack stack)
-    {
-        if (!stack.isEmpty())
-        {
-            float f = (float)stack.getAnimationsToGo() - partialTicks;
-
-            if (f > 0.0F)
-            {
-                GlStateManager.pushMatrix();
-                float f1 = 1.0F + f / 5.0F;
-                GlStateManager.translatef((float)(x + 8), (float)(y + 12), 0.0F);
-                GlStateManager.scalef(1.0F / f1, (f1 + 1.0F) / 2.0F, 1.0F);
-                GlStateManager.translatef((float)(-(x + 8)), (float)(-(y + 12)), 0.0F);
-            }
-
-            this.itemRenderer.renderItemAndEffectIntoGUI(player, stack, x, y);
-
-            if (f > 0.0F)
-            {
-                GlStateManager.popMatrix();
-            }
-
-            this.itemRenderer.renderItemOverlays(this.mc.fontRenderer, stack, x, y);
-        }
-    }
-
-    /**
-     * The update tick for the ingame UI
-     */
-    public void tick()
-    {
-        if (this.mc.world == null)
-        {
-            TextureAnimations.updateAnimations();
-        }
-
-        if (this.overlayMessageTime > 0)
-        {
-            --this.overlayMessageTime;
-        }
-
-        if (this.titlesTimer > 0)
-        {
-            --this.titlesTimer;
-
-            if (this.titlesTimer <= 0)
-            {
-                this.displayedTitle = "";
-                this.displayedSubTitle = "";
-            }
-        }
-
-        ++this.ticks;
-        Entity entity = this.mc.getRenderViewEntity();
-
-        if (entity != null)
-        {
-            this.updateVignetteBrightness(entity);
-        }
-
-        if (this.mc.player != null)
-        {
-            ItemStack itemstack = this.mc.player.inventory.getCurrentItem();
-
-            if (itemstack.isEmpty())
-            {
-                this.remainingHighlightTicks = 0;
-            }
-            else if (!this.highlightingItemStack.isEmpty() && itemstack.getItem() == this.highlightingItemStack.getItem() && itemstack.getDisplayName().equals(this.highlightingItemStack.getDisplayName()))
-            {
-                if (this.remainingHighlightTicks > 0)
-                {
-                    --this.remainingHighlightTicks;
-                }
-            }
-            else
-            {
-                this.remainingHighlightTicks = 40;
-            }
-
-            this.highlightingItemStack = itemstack;
-        }
-    }
-
-    public void setRecordPlayingMessage(String recordName)
-    {
-        this.setOverlayMessage(I18n.format("record.nowPlaying", recordName), true);
-    }
-
-    public void setOverlayMessage(String message, boolean animateColor)
-    {
-        this.overlayMessage = message;
-        this.overlayMessageTime = 60;
-        this.animateOverlayMessageColor = animateColor;
-    }
-
-    public void displayTitle(String title, String subTitle, int timeFadeIn, int displayTime, int timeFadeOut)
-    {
-        if (title == null && subTitle == null && timeFadeIn < 0 && displayTime < 0 && timeFadeOut < 0)
-        {
-            this.displayedTitle = "";
-            this.displayedSubTitle = "";
-            this.titlesTimer = 0;
-        }
-        else if (title != null)
-        {
-            this.displayedTitle = title;
-            this.titlesTimer = this.titleFadeIn + this.titleDisplayTime + this.titleFadeOut;
-        }
-        else if (subTitle != null)
-        {
-            this.displayedSubTitle = subTitle;
-        }
-        else
-        {
-            if (timeFadeIn >= 0)
-            {
-                this.titleFadeIn = timeFadeIn;
-            }
-
-            if (displayTime >= 0)
-            {
-                this.titleDisplayTime = displayTime;
-            }
-
-            if (timeFadeOut >= 0)
-            {
-                this.titleFadeOut = timeFadeOut;
-            }
-
-            if (this.titlesTimer > 0)
-            {
-                this.titlesTimer = this.titleFadeIn + this.titleDisplayTime + this.titleFadeOut;
-            }
-        }
-    }
-
-    public void setOverlayMessage(ITextComponent component, boolean animateColor)
-    {
-        this.setOverlayMessage(component.getString(), animateColor);
-    }
-
-    /**
-     * Forwards the given chat message to all listeners.
-     */
-    public void addChatMessage(ChatType chatTypeIn, ITextComponent message)
-    {
-        for (IChatListener ichatlistener : this.chatListeners.get(chatTypeIn))
-        {
-            ichatlistener.say(chatTypeIn, message);
-        }
-    }
-
-    /**
-     * returns a pointer to the persistant Chat GUI, containing all previous chat messages and such
-     */
-    public GuiNewChat getChatGUI()
-    {
-        return this.persistantChatGUI;
-    }
-
-    public int getTicks()
-    {
-        return this.ticks;
-    }
-
-    public FontRenderer getFontRenderer()
-    {
-        return this.mc.fontRenderer;
-    }
-
-    public GuiSpectator getSpectatorGui()
-    {
-        return this.spectatorGui;
-    }
-
-    public GuiPlayerTabOverlay getTabList()
-    {
-        return this.overlayPlayerList;
-    }
-
-    /**
-     * Reset the GuiPlayerTabOverlay's message header and footer
-     */
-    public void resetPlayersOverlayFooterHeader()
-    {
-        this.overlayPlayerList.resetFooterHeader();
-        this.overlayBoss.clearBossInfos();
-        this.mc.getToastGui().clear();
-    }
-
-    /**
-     * Accessor for the GuiBossOverlay
-     */
-    public GuiBossOverlay getBossOverlay()
-    {
-        return this.overlayBoss;
-    }
+		if (this.mc.playerController.getCurrentGameType() == GameType.SPECTATOR)
+		{
+			this.spectatorGui.renderTooltip(partialTicks);
+		}
+		else if (!this.mc.gameSettings.hideGUI)
+		{
+			this.renderHotbar(partialTicks);
+		}
+
+		if (!this.mc.gameSettings.hideGUI)
+		{
+			GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+			this.mc.getTextureManager().bindTexture(ICONS);
+			GlStateManager.enableBlend();
+			GlStateManager.enableAlphaTest();
+			//VIVECRAFT NOPE!
+			//this.renderAttackIndicator(partialTicks);
+			//
+			GlStateManager.enableAlphaTest();
+			// VIVECRAFT: DestFactor of ONE is really what we want here, because math
+			GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+			this.mc.profiler.startSection("bossHealth");
+			this.overlayBoss.renderBossHealth();
+			this.mc.profiler.endSection();
+			GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+			this.mc.getTextureManager().bindTexture(ICONS);
+
+			if (this.mc.playerController.shouldDrawHUD())
+			{
+				this.renderPlayerStats();
+			}
+
+			this.renderVehicleHealth();
+			GlStateManager.disableBlend();
+			int k = this.scaledWidth / 2 - 91;
+
+			if (this.mc.player.isRidingHorse())
+			{
+				this.renderHorseJumpBar(k);
+			}
+			else if (this.mc.playerController.gameIsSurvivalOrAdventure())
+			{
+				this.renderExpBar(k);
+			}
+
+			if (this.mc.gameSettings.heldItemTooltips && this.mc.playerController.getCurrentGameType() != GameType.SPECTATOR)
+			{
+				this.renderSelectedItem();
+			}
+			else if (this.mc.player.isSpectator())
+			{
+				this.spectatorGui.renderSelectedItem();
+			}
+		}
+
+		if (this.mc.player.getSleepTimer() > 0)
+		{
+			this.mc.profiler.startSection("sleep");
+			GlStateManager.disableDepthTest();
+			GlStateManager.disableAlphaTest();
+			float f2 = (float)this.mc.player.getSleepTimer();
+			float f1 = f2 / 100.0F;
+
+			if (f1 > 1.0F)
+			{
+				f1 = 1.0F - (f2 - 100.0F) / 10.0F;
+			}
+
+			int i = (int)(220.0F * f1) << 24 | 1052704;
+			drawRect(0, 0, this.scaledWidth, this.scaledHeight, i);
+			GlStateManager.enableAlphaTest();
+			GlStateManager.enableDepthTest();
+			this.mc.profiler.endSection();
+			GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+		}
+
+		if (this.mc.isDemo())
+		{
+			this.renderDemoOverlay();
+		}
+
+		this.renderPotionEffects();
+
+		if (this.mc.gameSettings.showDebugInfo)
+		{
+			this.overlayDebug.render();
+		}
+
+		if (!this.mc.gameSettings.hideGUI)
+		{
+			if (this.overlayMessageTime > 0)
+			{
+				this.mc.profiler.startSection("overlayMessage");
+				float f3 = (float)this.overlayMessageTime - partialTicks;
+				int l = (int)(f3 * 255.0F / 20.0F);
+
+				if (l > 255)
+				{
+					l = 255;
+				}
+
+				if (l > 8)
+				{
+					GlStateManager.pushMatrix();
+					GlStateManager.translatef((float)(this.scaledWidth / 2), (float)(this.scaledHeight - 68), 0.0F);
+					GlStateManager.enableBlend();
+					// VIVECRAFT: DestFactor of ONE is really what we want here, because math
+					GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+					int j1 = 16777215;
+
+					if (this.animateOverlayMessageColor)
+					{
+						j1 = MathHelper.hsvToRGB(f3 / 50.0F, 0.7F, 0.6F) & 16777215;
+					}
+
+					fontrenderer.drawString(this.overlayMessage, (float)(-fontrenderer.getStringWidth(this.overlayMessage) / 2), -4.0F, j1 + (l << 24 & -16777216));
+					GlStateManager.disableBlend();
+					GlStateManager.popMatrix();
+				}
+
+				this.mc.profiler.endSection();
+			}
+
+			if (this.titlesTimer > 0)
+			{
+				this.mc.profiler.startSection("titleAndSubtitle");
+				float f4 = (float)this.titlesTimer - partialTicks;
+				int i1 = 255;
+
+				if (this.titlesTimer > this.titleFadeOut + this.titleDisplayTime)
+				{
+					float f5 = (float)(this.titleFadeIn + this.titleDisplayTime + this.titleFadeOut) - f4;
+					i1 = (int)(f5 * 255.0F / (float)this.titleFadeIn);
+				}
+
+				if (this.titlesTimer <= this.titleFadeOut)
+				{
+					i1 = (int)(f4 * 255.0F / (float)this.titleFadeOut);
+				}
+
+				i1 = MathHelper.clamp(i1, 0, 255);
+
+				if (i1 > 8)
+				{
+					GlStateManager.pushMatrix();
+					GlStateManager.translatef((float)(this.scaledWidth / 2), (float)(this.scaledHeight / 2), 0.0F);
+					GlStateManager.enableBlend();
+					// VIVECRAFT: DestFactor of ONE is really what we want here, because math
+					GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+					GlStateManager.pushMatrix();
+					GlStateManager.scalef(4.0F, 4.0F, 4.0F);
+					int k1 = i1 << 24 & -16777216;
+					fontrenderer.drawStringWithShadow(this.displayedTitle, (float)(-fontrenderer.getStringWidth(this.displayedTitle) / 2), -10.0F, 16777215 | k1);
+					GlStateManager.popMatrix();
+					GlStateManager.pushMatrix();
+					GlStateManager.scalef(2.0F, 2.0F, 2.0F);
+					fontrenderer.drawStringWithShadow(this.displayedSubTitle, (float)(-fontrenderer.getStringWidth(this.displayedSubTitle) / 2), 5.0F, 16777215 | k1);
+					GlStateManager.popMatrix();
+					GlStateManager.disableBlend();
+					GlStateManager.popMatrix();
+				}
+
+				this.mc.profiler.endSection();
+			}
+
+			this.overlaySubtitle.render();
+			Scoreboard scoreboard = this.mc.world.getScoreboard();
+			ScoreObjective scoreobjective = null;
+			ScorePlayerTeam scoreplayerteam = scoreboard.getPlayersTeam(this.mc.player.getScoreboardName());
+
+			if (scoreplayerteam != null)
+			{
+				int j = scoreplayerteam.getColor().getColorIndex();
+
+				if (j >= 0)
+				{
+					scoreobjective = scoreboard.getObjectiveInDisplaySlot(3 + j);
+				}
+			}
+
+			ScoreObjective scoreobjective1 = scoreobjective != null ? scoreobjective : scoreboard.getObjectiveInDisplaySlot(1);
+
+			if (scoreobjective1 != null)
+			{
+				this.renderScoreboard(scoreobjective1);
+			}
+
+			if (mc.currentScreen != null) {
+				// VIVECRAFT: Dimming effect when in background
+				float brightness = 0.5F;
+				GlStateManager.enableBlend();
+				GlStateManager.blendFuncSeparate(SourceFactor.ZERO, DestFactor.ONE, SourceFactor.ZERO, DestFactor.SRC_ALPHA);
+				GlStateManager.disableTexture2D();
+				GlStateManager.depthMask(false);
+				Tessellator tessellator = Tessellator.getInstance();
+				BufferBuilder bufferbuilder = tessellator.getBuffer();
+				bufferbuilder.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);
+				bufferbuilder.pos(0.0D, mc.currentScreen.height, 990.0D).color(0.0F, 0.0F, 0.0F, brightness).endVertex();
+				bufferbuilder.pos(mc.currentScreen.width, mc.currentScreen.height, 990.0D).color(0.0F, 0.0F, 0.0F, brightness).endVertex();
+				bufferbuilder.pos(mc.currentScreen.width, 0.0D, 990.0D).color(0.0F, 0.0F, 0.0F, brightness).endVertex();
+				bufferbuilder.pos(0.0D, 0.0D, 990.0D).color(0.0F, 0.0F, 0.0F, brightness).endVertex();
+				tessellator.draw();
+				GlStateManager.depthMask(true);
+				GlStateManager.enableTexture2D();
+			}
+
+			GlStateManager.enableBlend();
+			// VIVECRAFT: DestFactor of ONE is really what we want here, because math
+			GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+			GlStateManager.disableAlphaTest();
+			GlStateManager.pushMatrix();
+			GlStateManager.translatef(0.0F, (float)(this.scaledHeight - 48), 0.0F);
+			this.mc.profiler.startSection("chat");
+			this.persistantChatGUI.drawChat(this.ticks);
+			this.mc.profiler.endSection();
+			GlStateManager.popMatrix();
+			scoreobjective1 = scoreboard.getObjectiveInDisplaySlot(0);
+
+			if (this.mc.gameSettings.keyBindPlayerList.isKeyDown() && (!this.mc.isIntegratedServerRunning() || this.mc.player.connection.getPlayerInfoMap().size() > 1 || scoreobjective1 != null))
+			{
+				this.overlayPlayerList.setVisible(true);
+				this.overlayPlayerList.renderPlayerlist(this.scaledWidth, scoreboard, scoreobjective1);
+			}
+			else
+			{
+				this.overlayPlayerList.setVisible(false);
+			}
+		}
+
+		GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+		GlStateManager.disableLighting();
+		GlStateManager.enableAlphaTest();
+	}
+
+	private void renderAttackIndicator(float partialTicks)
+	{
+		GameSettings gamesettings = this.mc.gameSettings;
+
+		if (gamesettings.thirdPersonView == 0)
+		{
+			if (this.mc.playerController.getCurrentGameType() == GameType.SPECTATOR && this.mc.pointedEntity == null)
+			{
+				RayTraceResult raytraceresult = this.mc.objectMouseOver;
+
+				if (raytraceresult == null || raytraceresult.type != RayTraceResult.Type.BLOCK)
+				{
+					return;
+				}
+
+				BlockPos blockpos = raytraceresult.getBlockPos();
+				IBlockState iblockstate = this.mc.world.getBlockState(blockpos);
+
+				if (!ReflectorForge.blockHasTileEntity(iblockstate) || !(this.mc.world.getTileEntity(blockpos) instanceof IInventory))
+				{
+					return;
+				}
+			}
+
+			if (gamesettings.showDebugInfo && !gamesettings.hideGUI && !this.mc.player.hasReducedDebug() && !gamesettings.reducedDebugInfo)
+			{
+				GlStateManager.pushMatrix();
+				GlStateManager.translatef((float)(this.scaledWidth / 2), (float)(this.scaledHeight / 2), this.zLevel);
+				Entity entity = this.mc.getRenderViewEntity();
+				GlStateManager.rotatef(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks, -1.0F, 0.0F, 0.0F);
+				GlStateManager.rotatef(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks, 0.0F, 1.0F, 0.0F);
+				GlStateManager.scalef(-1.0F, -1.0F, -1.0F);
+				OpenGlHelper.renderDirections(10);
+				GlStateManager.popMatrix();
+			}
+			else
+			{
+				// VIVECRAFT: DestFactor of ONE is really what we want here, because math
+				GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.ONE_MINUS_DST_COLOR, GlStateManager.DestFactor.ONE_MINUS_SRC_COLOR, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+				int l = 15;
+				this.drawTexturedModalRect((float)this.scaledWidth / 2.0F - 7.5F, (float)this.scaledHeight / 2.0F - 7.5F, 0, 0, 15, 15);
+
+				if (this.mc.gameSettings.attackIndicator == 1)
+				{
+					float f = this.mc.player.getCooledAttackStrength(0.0F);
+					boolean flag = false;
+
+					if (this.mc.pointedEntity != null && this.mc.pointedEntity instanceof EntityLivingBase && f >= 1.0F)
+					{
+						flag = this.mc.player.getCooldownPeriod() > 5.0F;
+						flag = flag & this.mc.pointedEntity.isEntityAlive();
+					}
+
+					int i = this.scaledHeight / 2 - 7 + 16;
+					int j = this.scaledWidth / 2 - 8;
+
+					if (flag)
+					{
+						this.drawTexturedModalRect(j, i, 68, 94, 16, 16);
+					}
+					else if (f < 1.0F)
+					{
+						int k = (int)(f * 17.0F);
+						this.drawTexturedModalRect(j, i, 36, 94, 16, 4);
+						this.drawTexturedModalRect(j, i, 52, 94, k, 4);
+					}
+				}
+			}
+		}
+	}
+
+	protected void renderPotionEffects()
+	{
+		Collection<PotionEffect> collection = this.mc.player.getActivePotionEffects();
+
+		if (!collection.isEmpty())
+		{
+			this.mc.getTextureManager().bindTexture(GuiContainer.INVENTORY_BACKGROUND);
+			GlStateManager.enableBlend();
+			int i = 0;
+			int j = 0;
+			Iterator iterator = Ordering.natural().reverse().sortedCopy(collection).iterator();
+
+			while (true)
+			{
+				PotionEffect potioneffect;
+				Potion potion;
+				boolean flag;
+
+				while (true)
+				{
+					if (!iterator.hasNext())
+					{
+						return;
+					}
+
+					potioneffect = (PotionEffect)iterator.next();
+					potion = potioneffect.getPotion();
+					flag = potion.hasStatusIcon();
+
+					if (!Reflector.ForgePotion_shouldRenderHUD.exists())
+					{
+						break;
+					}
+
+					if (Reflector.callBoolean(potion, Reflector.ForgePotion_shouldRenderHUD, potioneffect))
+					{
+						this.mc.getTextureManager().bindTexture(GuiContainer.INVENTORY_BACKGROUND);
+						flag = true;
+						break;
+					}
+				}
+
+				if (flag && potioneffect.isShowIcon())
+				{
+					int k = this.scaledWidth;
+					int l = 1;
+
+					if (this.mc.isDemo())
+					{
+						l += 15;
+					}
+
+					int i1 = potion.getStatusIconIndex();
+
+					if (potion.isBeneficial())
+					{
+						++i;
+						k = k - 25 * i;
+					}
+					else
+					{
+						++j;
+						k = k - 25 * j;
+						l += 26;
+					}
+
+					GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+					float f = 1.0F;
+
+					if (potioneffect.isAmbient())
+					{
+						this.drawTexturedModalRect(k, l, 165, 166, 24, 24);
+					}
+					else
+					{
+						this.drawTexturedModalRect(k, l, 141, 166, 24, 24);
+
+						if (potioneffect.getDuration() <= 200)
+						{
+							int j1 = 10 - potioneffect.getDuration() / 20;
+							f = MathHelper.clamp((float)potioneffect.getDuration() / 10.0F / 5.0F * 0.5F, 0.0F, 0.5F) + MathHelper.cos((float)potioneffect.getDuration() * (float)Math.PI / 5.0F) * MathHelper.clamp((float)j1 / 10.0F * 0.25F, 0.0F, 0.25F);
+						}
+					}
+
+					GlStateManager.color4f(1.0F, 1.0F, 1.0F, f);
+
+					if (Reflector.ForgePotion_renderHUDEffect.exists())
+					{
+						if (potion.hasStatusIcon())
+						{
+							this.drawTexturedModalRect(k + 3, l + 3, i1 % 8 * 18, 198 + i1 / 8 * 18, 18, 18);
+						}
+
+						Reflector.call(potion, Reflector.ForgePotion_renderHUDEffect, k, l, potioneffect, this.mc, f);
+					}
+					else
+					{
+						int l1 = i1 % 12;
+						int k1 = i1 / 12;
+						this.drawTexturedModalRect(k + 3, l + 3, l1 * 18, 198 + k1 * 18, 18, 18);
+					}
+				}
+			}
+		}
+	}
+
+	protected void renderHotbar(float partialTicks)
+	{
+		EntityPlayer entityplayer = this.getRenderViewPlayer();
+
+		if (entityplayer != null)
+		{
+			GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+			this.mc.getTextureManager().bindTexture(WIDGETS_TEX_PATH);
+			ItemStack itemstack = entityplayer.getHeldItemOffhand();
+			EnumHandSide enumhandside = entityplayer.getPrimaryHand().opposite();
+			int i = this.scaledWidth / 2;
+			float f = this.zLevel;
+			int j = 182;
+			int k = 91;
+			this.zLevel = -90.0F;
+			//VIVECRAFT
+			GlStateManager.enableAlphaTest();
+			///
+			this.drawTexturedModalRect(i - 91, this.scaledHeight - 22, 0, 0, 182, 22);
+			this.drawTexturedModalRect(i - 91 - 1 + entityplayer.inventory.currentItem * 20, this.scaledHeight - 22 - 1, 0, 22, 24, 22);
+
+			if (!itemstack.isEmpty())
+			{
+				if (enumhandside == EnumHandSide.LEFT)
+				{
+					this.drawTexturedModalRect(i - 91 - 29, this.scaledHeight - 23, 24, 22, 29, 24);
+				}
+				else
+				{
+					this.drawTexturedModalRect(i + 91, this.scaledHeight - 23, 53, 22, 29, 24);
+				}
+			}
+
+			this.zLevel = f;
+			GlStateManager.enableRescaleNormal();
+			GlStateManager.enableBlend();
+			// VIVECRAFT: DestFactor of ONE is really what we want here, because math
+			GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+			RenderHelper.enableGUIStandardItemLighting();
+			CustomItems.setRenderOffHand(false);
+
+			for (int l = 0; l < 9; ++l)
+			{
+				int i1 = i - 90 + l * 20 + 2;
+				int j1 = this.scaledHeight - 16 - 3;
+				this.renderHotbarItem(i1, j1, partialTicks, entityplayer, entityplayer.inventory.mainInventory.get(l));
+			}
+
+			if (!itemstack.isEmpty())
+			{
+				CustomItems.setRenderOffHand(true);
+				int l1 = this.scaledHeight - 16 - 3;
+
+				if (enumhandside == EnumHandSide.LEFT)
+				{
+					this.renderHotbarItem(i - 91 - 26, l1, partialTicks, entityplayer, itemstack);
+				}
+				else
+				{
+					this.renderHotbarItem(i + 91 + 10, l1, partialTicks, entityplayer, itemstack);
+				}
+
+				CustomItems.setRenderOffHand(false);
+			}
+
+			if (this.mc.gameSettings.attackIndicator == 2)
+			{
+				float f1 = this.mc.player.getCooledAttackStrength(0.0F);
+
+				if (f1 < 1.0F)
+				{
+					int i2 = this.scaledHeight - 20;
+					int j2 = i + 91 + 6;
+
+					if (enumhandside == EnumHandSide.RIGHT)
+					{
+						j2 = i - 91 - 22;
+					}
+
+					this.mc.getTextureManager().bindTexture(Gui.ICONS);
+					int k1 = (int)(f1 * 19.0F);
+					GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+					this.drawTexturedModalRect(j2, i2, 0, 94, 18, 18);
+					this.drawTexturedModalRect(j2, i2 + 18 - k1, 18, 112 - k1, 18, k1);
+				}
+			}
+
+			RenderHelper.disableStandardItemLighting();
+			GlStateManager.disableRescaleNormal();
+			GlStateManager.disableBlend();
+		}
+	}
+
+	public void renderHorseJumpBar(int x)
+	{
+		this.mc.profiler.startSection("jumpBar");
+		this.mc.getTextureManager().bindTexture(Gui.ICONS);
+		float f = this.mc.player.getHorseJumpPower();
+		int i = 182;
+		int j = (int)(f * 183.0F);
+		int k = this.scaledHeight - 32 + 3;
+		this.drawTexturedModalRect(x, k, 0, 84, 182, 5);
+
+		if (j > 0)
+		{
+			this.drawTexturedModalRect(x, k, 0, 89, j, 5);
+		}
+
+		this.mc.profiler.endSection();
+	}
+
+	public void renderExpBar(int x)
+	{
+		this.mc.profiler.startSection("expBar");
+		this.mc.getTextureManager().bindTexture(Gui.ICONS);
+		int i = this.mc.player.xpBarCap();
+
+		if (i > 0)
+		{
+			int j = 182;
+			int k = (int)(this.mc.player.experience * 183.0F);
+			int l = this.scaledHeight - 32 + 3;
+			this.drawTexturedModalRect(x, l, 0, 64, 182, 5);
+
+			if (k > 0)
+			{
+				this.drawTexturedModalRect(x, l, 0, 69, k, 5);
+			}
+		}
+
+		this.mc.profiler.endSection();
+
+		if (this.mc.player.experienceLevel > 0)
+		{
+			this.mc.profiler.startSection("expLevel");
+			int j1 = 8453920;
+
+			if (Config.isCustomColors())
+			{
+				j1 = CustomColors.getExpBarTextColor(j1);
+			}
+
+			String s = "" + this.mc.player.experienceLevel;
+			int k1 = (this.scaledWidth - this.getFontRenderer().getStringWidth(s)) / 2;
+			int i1 = this.scaledHeight - 31 - 4;
+			this.getFontRenderer().drawString(s, (float)(k1 + 1), (float)i1, 0);
+			this.getFontRenderer().drawString(s, (float)(k1 - 1), (float)i1, 0);
+			this.getFontRenderer().drawString(s, (float)k1, (float)(i1 + 1), 0);
+			this.getFontRenderer().drawString(s, (float)k1, (float)(i1 - 1), 0);
+			this.getFontRenderer().drawString(s, (float)k1, (float)i1, j1);
+			this.mc.profiler.endSection();
+		}
+	}
+
+	public void renderSelectedItem()
+	{
+		this.mc.profiler.startSection("selectedItemName");
+
+		if (this.remainingHighlightTicks > 0 && !this.highlightingItemStack.isEmpty())
+		{
+			ITextComponent itextcomponent = (new TextComponentString("")).appendSibling(this.highlightingItemStack.getDisplayName()).applyTextStyle(this.highlightingItemStack.getRarity().color);
+
+			if (this.highlightingItemStack.hasDisplayName())
+			{
+				itextcomponent.applyTextStyle(TextFormatting.ITALIC);
+			}
+
+			String s = itextcomponent.getFormattedText();
+			int i = (this.scaledWidth - this.getFontRenderer().getStringWidth(s)) / 2;
+			int j = this.scaledHeight - 59;
+
+			if (!this.mc.playerController.shouldDrawHUD())
+			{
+				j += 14;
+			}
+
+			int k = (int)((float)this.remainingHighlightTicks * 256.0F / 10.0F);
+
+			if (k > 255)
+			{
+				k = 255;
+			}
+
+			if (k > 0)
+			{
+				GlStateManager.pushMatrix();
+				GlStateManager.enableBlend();
+				// VIVECRAFT: DestFactor of ONE is really what we want here, because math
+				GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+				this.getFontRenderer().drawStringWithShadow(s, (float)i, (float)j, 16777215 + (k << 24));
+				GlStateManager.disableBlend();
+				GlStateManager.popMatrix();
+			}
+		}
+
+		this.mc.profiler.endSection();
+	}
+
+	public void renderDemoOverlay()
+	{
+		this.mc.profiler.startSection("demo");
+		String s;
+
+		if (this.mc.world.getGameTime() >= 120500L)
+		{
+			s = I18n.format("demo.demoExpired");
+		}
+		else
+		{
+			s = I18n.format("demo.remainingTime", StringUtils.ticksToElapsedTime((int)(120500L - this.mc.world.getGameTime())));
+		}
+
+		int i = this.getFontRenderer().getStringWidth(s);
+		this.getFontRenderer().drawStringWithShadow(s, (float)(this.scaledWidth - i - 10), 5.0F, 16777215);
+		this.mc.profiler.endSection();
+	}
+
+	private void renderScoreboard(ScoreObjective objective)
+	{
+		Scoreboard scoreboard = objective.getScoreboard();
+		Collection<Score> collection = scoreboard.getSortedScores(objective);
+		List<Score> list = (List)collection.stream().filter((p_lambda$renderScoreboard$0_0_) ->
+		{
+			return p_lambda$renderScoreboard$0_0_.getPlayerName() != null && !p_lambda$renderScoreboard$0_0_.getPlayerName().startsWith("#");
+		}).collect(Collectors.toList());
+
+		if (list.size() > 15)
+		{
+			collection = Lists.newArrayList(Iterables.skip(list, collection.size() - 15));
+		}
+		else
+		{
+			collection = list;
+		}
+
+		String s = objective.getDisplayName().getFormattedText();
+		int i = this.getFontRenderer().getStringWidth(s);
+		int j = i;
+
+		for (Score score : collection)
+		{
+			ScorePlayerTeam scoreplayerteam = scoreboard.getPlayersTeam(score.getPlayerName());
+			String s1 = ScorePlayerTeam.formatMemberName(scoreplayerteam, new TextComponentString(score.getPlayerName())).getFormattedText() + ": " + TextFormatting.RED + score.getScorePoints();
+			j = Math.max(j, this.getFontRenderer().getStringWidth(s1));
+		}
+
+		int j1 = collection.size() * this.getFontRenderer().FONT_HEIGHT;
+		int k1 = this.scaledHeight / 2 + j1 / 3;
+		int l1 = 3;
+		int i2 = this.scaledWidth - j - 3;
+		int k = 0;
+
+		for (Score score1 : collection)
+		{
+			++k;
+			ScorePlayerTeam scoreplayerteam1 = scoreboard.getPlayersTeam(score1.getPlayerName());
+			String s2 = ScorePlayerTeam.formatMemberName(scoreplayerteam1, new TextComponentString(score1.getPlayerName())).getFormattedText();
+			String s3 = TextFormatting.RED + "" + score1.getScorePoints();
+			int l = k1 - k * this.getFontRenderer().FONT_HEIGHT;
+			int i1 = this.scaledWidth - 3 + 2;
+			drawRect(i2 - 2, l, i1, l + this.getFontRenderer().FONT_HEIGHT, 1342177280);
+			this.getFontRenderer().drawString(s2, (float)i2, (float)l, 553648127);
+			this.getFontRenderer().drawString(s3, (float)(i1 - this.getFontRenderer().getStringWidth(s3)), (float)l, 553648127);
+
+			if (k == collection.size())
+			{
+				drawRect(i2 - 2, l - this.getFontRenderer().FONT_HEIGHT - 1, i1, l - 1, 1610612736);
+				drawRect(i2 - 2, l - 1, i1, l, 1342177280);
+				this.getFontRenderer().drawString(s, (float)(i2 + j / 2 - i / 2), (float)(l - this.getFontRenderer().FONT_HEIGHT), 553648127);
+			}
+		}
+	}
+
+	private EntityPlayer getRenderViewPlayer()
+	{
+		return !(this.mc.getRenderViewEntity() instanceof EntityPlayer) ? null : (EntityPlayer)this.mc.getRenderViewEntity();
+	}
+
+	private EntityLivingBase getMountEntity()
+	{
+		EntityPlayer entityplayer = this.getRenderViewPlayer();
+
+		if (entityplayer != null)
+		{
+			Entity entity = entityplayer.getRidingEntity();
+
+			if (entity == null)
+			{
+				return null;
+			}
+
+			if (entity instanceof EntityLivingBase)
+			{
+				return (EntityLivingBase)entity;
+			}
+		}
+
+		return null;
+	}
+
+	private int getRenderMountHealth(EntityLivingBase p_502210_1_)
+	{
+		if (p_502210_1_ != null && p_502210_1_.isLiving())
+		{
+			float f = p_502210_1_.getMaxHealth();
+			int i = (int)(f + 0.5F) / 2;
+
+			if (i > 30)
+			{
+				i = 30;
+			}
+
+			return i;
+		}
+		else
+		{
+			return 0;
+		}
+	}
+
+	private int func_502211_c(int p_502211_1_)
+	{
+		return (int)Math.ceil((double)p_502211_1_ / 10.0D);
+	}
+
+	private void renderPlayerStats()
+	{
+		EntityPlayer entityplayer = this.getRenderViewPlayer();
+
+		if (entityplayer != null)
+		{
+			int i = MathHelper.ceil(entityplayer.getHealth());
+			boolean flag = this.healthUpdateCounter > (long)this.ticks && (this.healthUpdateCounter - (long)this.ticks) / 3L % 2L == 1L;
+			long j = Util.milliTime();
+
+			if (i < this.playerHealth && entityplayer.hurtResistantTime > 0)
+			{
+				this.lastSystemTime = j;
+				this.healthUpdateCounter = (long)(this.ticks + 20);
+			}
+			else if (i > this.playerHealth && entityplayer.hurtResistantTime > 0)
+			{
+				this.lastSystemTime = j;
+				this.healthUpdateCounter = (long)(this.ticks + 10);
+			}
+
+			if (j - this.lastSystemTime > 1000L)
+			{
+				this.playerHealth = i;
+				this.lastPlayerHealth = i;
+				this.lastSystemTime = j;
+			}
+
+			this.playerHealth = i;
+			int k = this.lastPlayerHealth;
+			this.rand.setSeed((long)(this.ticks * 312871));
+			FoodStats foodstats = entityplayer.getFoodStats();
+			int l = foodstats.getFoodLevel();
+			IAttributeInstance iattributeinstance = entityplayer.getAttribute(SharedMonsterAttributes.MAX_HEALTH);
+			int i1 = this.scaledWidth / 2 - 91;
+			int j1 = this.scaledWidth / 2 + 91;
+			int k1 = this.scaledHeight - 39;
+			float f = (float)iattributeinstance.getValue();
+			int l1 = MathHelper.ceil(entityplayer.getAbsorptionAmount());
+			int i2 = MathHelper.ceil((f + (float)l1) / 2.0F / 10.0F);
+			int j2 = Math.max(10 - (i2 - 2), 3);
+			int k2 = k1 - (i2 - 1) * j2 - 10;
+			int l2 = k1 - 10;
+			int i3 = l1;
+			int j3 = entityplayer.getTotalArmorValue();
+			int k3 = -1;
+
+			if (entityplayer.isPotionActive(MobEffects.REGENERATION))
+			{
+				k3 = this.ticks % MathHelper.ceil(f + 5.0F);
+			}
+
+			this.mc.profiler.startSection("armor");
+
+			for (int l3 = 0; l3 < 10; ++l3)
+			{
+				if (j3 > 0)
+				{
+					int i4 = i1 + l3 * 8;
+
+					if (l3 * 2 + 1 < j3)
+					{
+						this.drawTexturedModalRect(i4, k2, 34, 9, 9, 9);
+					}
+
+					if (l3 * 2 + 1 == j3)
+					{
+						this.drawTexturedModalRect(i4, k2, 25, 9, 9, 9);
+					}
+
+					if (l3 * 2 + 1 > j3)
+					{
+						this.drawTexturedModalRect(i4, k2, 16, 9, 9, 9);
+					}
+				}
+			}
+
+			this.mc.profiler.endStartSection("health");
+
+			for (int l5 = MathHelper.ceil((f + (float)l1) / 2.0F) - 1; l5 >= 0; --l5)
+			{
+				int i6 = 16;
+
+				if (entityplayer.isPotionActive(MobEffects.POISON))
+				{
+					i6 += 36;
+				}
+				else if (entityplayer.isPotionActive(MobEffects.WITHER))
+				{
+					i6 += 72;
+				}
+
+				int j4 = 0;
+
+				if (flag)
+				{
+					j4 = 1;
+				}
+
+				int k4 = MathHelper.ceil((float)(l5 + 1) / 10.0F) - 1;
+				int l4 = i1 + l5 % 10 * 8;
+				int i5 = k1 - k4 * j2;
+
+				if (i <= 4)
+				{
+					i5 += this.rand.nextInt(2);
+				}
+
+				if (i3 <= 0 && l5 == k3)
+				{
+					i5 -= 2;
+				}
+
+				int j5 = 0;
+
+				if (entityplayer.world.getWorldInfo().isHardcoreModeEnabled())
+				{
+					j5 = 5;
+				}
+
+				this.drawTexturedModalRect(l4, i5, 16 + j4 * 9, 9 * j5, 9, 9);
+
+				if (flag)
+				{
+					if (l5 * 2 + 1 < k)
+					{
+						this.drawTexturedModalRect(l4, i5, i6 + 54, 9 * j5, 9, 9);
+					}
+
+					if (l5 * 2 + 1 == k)
+					{
+						this.drawTexturedModalRect(l4, i5, i6 + 63, 9 * j5, 9, 9);
+					}
+				}
+
+				if (i3 > 0)
+				{
+					if (i3 == l1 && l1 % 2 == 1)
+					{
+						this.drawTexturedModalRect(l4, i5, i6 + 153, 9 * j5, 9, 9);
+						--i3;
+					}
+					else
+					{
+						this.drawTexturedModalRect(l4, i5, i6 + 144, 9 * j5, 9, 9);
+						i3 -= 2;
+					}
+				}
+				else
+				{
+					if (l5 * 2 + 1 < i)
+					{
+						this.drawTexturedModalRect(l4, i5, i6 + 36, 9 * j5, 9, 9);
+					}
+
+					if (l5 * 2 + 1 == i)
+					{
+						this.drawTexturedModalRect(l4, i5, i6 + 45, 9 * j5, 9, 9);
+					}
+				}
+			}
+
+			EntityLivingBase entitylivingbase = this.getMountEntity();
+			int j6 = this.getRenderMountHealth(entitylivingbase);
+
+			if (j6 == 0)
+			{
+				this.mc.profiler.endStartSection("food");
+
+				for (int k6 = 0; k6 < 10; ++k6)
+				{
+					int i7 = k1;
+					int k7 = 16;
+					int i8 = 0;
+
+					if (entityplayer.isPotionActive(MobEffects.HUNGER))
+					{
+						k7 += 36;
+						i8 = 13;
+					}
+
+					if (entityplayer.getFoodStats().getSaturationLevel() <= 0.0F && this.ticks % (l * 3 + 1) == 0)
+					{
+						i7 = k1 + (this.rand.nextInt(3) - 1);
+					}
+
+					int k8 = j1 - k6 * 8 - 9;
+					this.drawTexturedModalRect(k8, i7, 16 + i8 * 9, 27, 9, 9);
+
+					if (k6 * 2 + 1 < l)
+					{
+						this.drawTexturedModalRect(k8, i7, k7 + 36, 27, 9, 9);
+					}
+
+					if (k6 * 2 + 1 == l)
+					{
+						this.drawTexturedModalRect(k8, i7, k7 + 45, 27, 9, 9);
+					}
+				}
+
+				l2 -= 10;
+			}
+
+			this.mc.profiler.endStartSection("air");
+			int l6 = entityplayer.getAir();
+			int j7 = entityplayer.getMaxAir();
+
+			if (entityplayer.areEyesInFluid(FluidTags.WATER) || l6 < j7)
+			{
+				int l7 = this.func_502211_c(j6) - 1;
+				l2 = l2 - l7 * 10;
+				int j8 = MathHelper.ceil((double)(l6 - 2) * 10.0D / (double)j7);
+				int l8 = MathHelper.ceil((double)l6 * 10.0D / (double)j7) - j8;
+
+				for (int k5 = 0; k5 < j8 + l8; ++k5)
+				{
+					if (k5 < j8)
+					{
+						this.drawTexturedModalRect(j1 - k5 * 8 - 9, l2, 16, 18, 9, 9);
+					}
+					else
+					{
+						this.drawTexturedModalRect(j1 - k5 * 8 - 9, l2, 25, 18, 9, 9);
+					}
+				}
+			}
+
+			this.mc.profiler.endSection();
+		}
+	}
+
+	private void renderVehicleHealth()
+	{
+		EntityLivingBase entitylivingbase = this.getMountEntity();
+
+		if (entitylivingbase != null)
+		{
+			int i = this.getRenderMountHealth(entitylivingbase);
+
+			if (i != 0)
+			{
+				int j = (int)Math.ceil((double)entitylivingbase.getHealth());
+				this.mc.profiler.endStartSection("mountHealth");
+				int k = this.scaledHeight - 39;
+				int l = this.scaledWidth / 2 + 91;
+				int i1 = k;
+				int j1 = 0;
+
+				for (boolean flag = false; i > 0; j1 += 20)
+				{
+					int k1 = Math.min(i, 10);
+					i -= k1;
+
+					for (int l1 = 0; l1 < k1; ++l1)
+					{
+						int i2 = 52;
+						int j2 = 0;
+						int k2 = l - l1 * 8 - 9;
+						this.drawTexturedModalRect(k2, i1, 52 + j2 * 9, 9, 9, 9);
+
+						if (l1 * 2 + 1 + j1 < j)
+						{
+							this.drawTexturedModalRect(k2, i1, 88, 9, 9, 9);
+						}
+
+						if (l1 * 2 + 1 + j1 == j)
+						{
+							this.drawTexturedModalRect(k2, i1, 97, 9, 9, 9);
+						}
+					}
+
+					i1 -= 10;
+				}
+			}
+		}
+	}
+
+	private void renderPumpkinOverlay()
+	{
+		GlStateManager.disableDepthTest();
+		GlStateManager.depthMask(false);
+		// VIVECRAFT: DestFactor of ONE is really what we want here, because math
+		GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+		GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+		GlStateManager.disableAlphaTest();
+		this.mc.getTextureManager().bindTexture(PUMPKIN_BLUR_TEX_PATH);
+		Tessellator tessellator = Tessellator.getInstance();
+		BufferBuilder bufferbuilder = tessellator.getBuffer();
+		bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+		bufferbuilder.pos(0.0D, (double)this.scaledHeight, -90.0D).tex(0.0D, 1.0D).endVertex();
+		bufferbuilder.pos((double)this.scaledWidth, (double)this.scaledHeight, -90.0D).tex(1.0D, 1.0D).endVertex();
+		bufferbuilder.pos((double)this.scaledWidth, 0.0D, -90.0D).tex(1.0D, 0.0D).endVertex();
+		bufferbuilder.pos(0.0D, 0.0D, -90.0D).tex(0.0D, 0.0D).endVertex();
+		tessellator.draw();
+		GlStateManager.depthMask(true);
+		GlStateManager.enableDepthTest();
+		GlStateManager.enableAlphaTest();
+		GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+	}
+
+	private void updateVignetteBrightness(Entity entityIn)
+	{
+		if (entityIn != null)
+		{
+			float f = MathHelper.clamp(1.0F - entityIn.getBrightness(), 0.0F, 1.0F);
+			this.prevVignetteBrightness = (float)((double)this.prevVignetteBrightness + (double)(f - this.prevVignetteBrightness) * 0.01D);
+		}
+	}
+
+	private void renderVignette(Entity entityIn)
+	{
+		//VIVECRAFT NOPE!
+		if (true)return;
+		//
+		if (!Config.isVignetteEnabled())
+		{
+			GlStateManager.enableDepthTest();
+			// VIVECRAFT: DestFactor of ONE is really what we want here, because math
+			GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+		}
+		else
+		{
+			WorldBorder worldborder = this.mc.world.getWorldBorder();
+			float f = (float)worldborder.getClosestDistance(entityIn);
+			double d0 = Math.min(worldborder.getResizeSpeed() * (double)worldborder.getWarningTime() * 1000.0D, Math.abs(worldborder.getTargetSize() - worldborder.getDiameter()));
+			double d1 = Math.max((double)worldborder.getWarningDistance(), d0);
+
+			if ((double)f < d1)
+			{
+				f = 1.0F - (float)((double)f / d1);
+			}
+			else
+			{
+				f = 0.0F;
+			}
+
+			GlStateManager.disableDepthTest();
+			GlStateManager.depthMask(false);
+			// VIVECRAFT: DestFactor of ONE is really what we want here, because math
+			GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.ZERO, GlStateManager.DestFactor.ONE_MINUS_SRC_COLOR, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+
+			if (f > 0.0F)
+			{
+				GlStateManager.color4f(0.0F, f, f, 1.0F);
+			}
+			else
+			{
+				GlStateManager.color4f(this.prevVignetteBrightness, this.prevVignetteBrightness, this.prevVignetteBrightness, 1.0F);
+			}
+
+			this.mc.getTextureManager().bindTexture(VIGNETTE_TEX_PATH);
+			Tessellator tessellator = Tessellator.getInstance();
+			BufferBuilder bufferbuilder = tessellator.getBuffer();
+			bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+			bufferbuilder.pos(0.0D, (double)this.scaledHeight, -90.0D).tex(0.0D, 1.0D).endVertex();
+			bufferbuilder.pos((double)this.scaledWidth, (double)this.scaledHeight, -90.0D).tex(1.0D, 1.0D).endVertex();
+			bufferbuilder.pos((double)this.scaledWidth, 0.0D, -90.0D).tex(1.0D, 0.0D).endVertex();
+			bufferbuilder.pos(0.0D, 0.0D, -90.0D).tex(0.0D, 0.0D).endVertex();
+			tessellator.draw();
+			GlStateManager.depthMask(true);
+			GlStateManager.enableDepthTest();
+			GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+			// VIVECRAFT: DestFactor of ONE is really what we want here, because math
+			GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+		}
+	}
+
+	private void renderPortal(float timeInPortal)
+	{
+		//VIVECRAFT NOPE!
+		if(true) return;
+		//
+
+		if (timeInPortal < 1.0F)
+		{
+			timeInPortal = timeInPortal * timeInPortal;
+			timeInPortal = timeInPortal * timeInPortal;
+			timeInPortal = timeInPortal * 0.8F + 0.2F;
+		}
+
+		GlStateManager.disableAlphaTest();
+		GlStateManager.disableDepthTest();
+		GlStateManager.depthMask(false);
+		GlStateManager.blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
+		GlStateManager.color4f(1.0F, 1.0F, 1.0F, timeInPortal);
+		this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+		TextureAtlasSprite textureatlassprite = this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(Blocks.NETHER_PORTAL.getDefaultState());
+		float f = textureatlassprite.getMinU();
+		float f1 = textureatlassprite.getMinV();
+		float f2 = textureatlassprite.getMaxU();
+		float f3 = textureatlassprite.getMaxV();
+		Tessellator tessellator = Tessellator.getInstance();
+		BufferBuilder bufferbuilder = tessellator.getBuffer();
+		bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+		bufferbuilder.pos(0.0D, (double)this.scaledHeight, -90.0D).tex((double)f, (double)f3).endVertex();
+		bufferbuilder.pos((double)this.scaledWidth, (double)this.scaledHeight, -90.0D).tex((double)f2, (double)f3).endVertex();
+		bufferbuilder.pos((double)this.scaledWidth, 0.0D, -90.0D).tex((double)f2, (double)f1).endVertex();
+		bufferbuilder.pos(0.0D, 0.0D, -90.0D).tex((double)f, (double)f1).endVertex();
+		tessellator.draw();
+		GlStateManager.depthMask(true);
+		GlStateManager.enableDepthTest();
+		GlStateManager.enableAlphaTest();
+		GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
+	}
+
+	private void renderHotbarItem(int x, int y, float partialTicks, EntityPlayer player, ItemStack stack)
+	{
+		if (!stack.isEmpty())
+		{
+			float f = (float)stack.getAnimationsToGo() - partialTicks;
+
+			if (f > 0.0F)
+			{
+				GlStateManager.pushMatrix();
+				float f1 = 1.0F + f / 5.0F;
+				GlStateManager.translatef((float)(x + 8), (float)(y + 12), 0.0F);
+				GlStateManager.scalef(1.0F / f1, (f1 + 1.0F) / 2.0F, 1.0F);
+				GlStateManager.translatef((float)(-(x + 8)), (float)(-(y + 12)), 0.0F);
+			}
+
+			this.itemRenderer.renderItemAndEffectIntoGUI(player, stack, x, y);
+
+			if (f > 0.0F)
+			{
+				GlStateManager.popMatrix();
+			}
+
+			this.itemRenderer.renderItemOverlays(this.mc.fontRenderer, stack, x, y);
+		}
+	}
+
+	/**
+	 * The update tick for the ingame UI
+	 */
+	public void tick()
+	{
+		if (this.mc.world == null)
+		{
+			TextureAnimations.updateAnimations();
+		}
+
+		if (this.overlayMessageTime > 0)
+		{
+			--this.overlayMessageTime;
+		}
+
+		if (this.titlesTimer > 0)
+		{
+			--this.titlesTimer;
+
+			if (this.titlesTimer <= 0)
+			{
+				this.displayedTitle = "";
+				this.displayedSubTitle = "";
+			}
+		}
+
+		++this.ticks;
+		Entity entity = this.mc.getRenderViewEntity();
+
+		if (entity != null)
+		{
+			this.updateVignetteBrightness(entity);
+		}
+
+		if (this.mc.player != null)
+		{
+			ItemStack itemstack = this.mc.player.inventory.getCurrentItem();
+
+			if (itemstack.isEmpty())
+			{
+				this.remainingHighlightTicks = 0;
+			}
+			else if (!this.highlightingItemStack.isEmpty() && itemstack.getItem() == this.highlightingItemStack.getItem() && itemstack.getDisplayName().equals(this.highlightingItemStack.getDisplayName()))
+			{
+				if (this.remainingHighlightTicks > 0)
+				{
+					--this.remainingHighlightTicks;
+				}
+			}
+			else
+			{
+				this.remainingHighlightTicks = 40;
+			}
+
+			this.highlightingItemStack = itemstack;
+		}
+	}
+
+	public void setRecordPlayingMessage(String recordName)
+	{
+		this.setOverlayMessage(I18n.format("record.nowPlaying", recordName), true);
+	}
+
+	public void setOverlayMessage(String message, boolean animateColor)
+	{
+		this.overlayMessage = message;
+		this.overlayMessageTime = 60;
+		this.animateOverlayMessageColor = animateColor;
+	}
+
+	public void displayTitle(String title, String subTitle, int timeFadeIn, int displayTime, int timeFadeOut)
+	{
+		if (title == null && subTitle == null && timeFadeIn < 0 && displayTime < 0 && timeFadeOut < 0)
+		{
+			this.displayedTitle = "";
+			this.displayedSubTitle = "";
+			this.titlesTimer = 0;
+		}
+		else if (title != null)
+		{
+			this.displayedTitle = title;
+			this.titlesTimer = this.titleFadeIn + this.titleDisplayTime + this.titleFadeOut;
+		}
+		else if (subTitle != null)
+		{
+			this.displayedSubTitle = subTitle;
+		}
+		else
+		{
+			if (timeFadeIn >= 0)
+			{
+				this.titleFadeIn = timeFadeIn;
+			}
+
+			if (displayTime >= 0)
+			{
+				this.titleDisplayTime = displayTime;
+			}
+
+			if (timeFadeOut >= 0)
+			{
+				this.titleFadeOut = timeFadeOut;
+			}
+
+			if (this.titlesTimer > 0)
+			{
+				this.titlesTimer = this.titleFadeIn + this.titleDisplayTime + this.titleFadeOut;
+			}
+		}
+	}
+
+	public void setOverlayMessage(ITextComponent component, boolean animateColor)
+	{
+		this.setOverlayMessage(component.getString(), animateColor);
+	}
+
+	/**
+	 * Forwards the given chat message to all listeners.
+	 */
+	public void addChatMessage(ChatType chatTypeIn, ITextComponent message)
+	{
+		for (IChatListener ichatlistener : this.chatListeners.get(chatTypeIn))
+		{
+			ichatlistener.say(chatTypeIn, message);
+		}
+	}
+
+	/**
+	 * returns a pointer to the persistant Chat GUI, containing all previous chat messages and such
+	 */
+	public GuiNewChat getChatGUI()
+	{
+		return this.persistantChatGUI;
+	}
+
+	public int getTicks()
+	{
+		return this.ticks;
+	}
+
+	public FontRenderer getFontRenderer()
+	{
+		return this.mc.fontRenderer;
+	}
+
+	public GuiSpectator getSpectatorGui()
+	{
+		return this.spectatorGui;
+	}
+
+	public GuiPlayerTabOverlay getTabList()
+	{
+		return this.overlayPlayerList;
+	}
+
+	/**
+	 * Reset the GuiPlayerTabOverlay's message header and footer
+	 */
+	public void resetPlayersOverlayFooterHeader()
+	{
+		this.overlayPlayerList.resetFooterHeader();
+		this.overlayBoss.clearBossInfos();
+		this.mc.getToastGui().clear();
+	}
+
+	/**
+	 * Accessor for the GuiBossOverlay
+	 */
+	public GuiBossOverlay getBossOverlay()
+	{
+		return this.overlayBoss;
+	}
+
+	//VIVECRAFT ADDITIONS ***********************************
+
+	public void drawMouseMenuQuad(int mouseX, int mouseY)
+	{	
+		GlStateManager.enableBlend();
+		GlStateManager.enableAlphaTest();
+		GlStateManager.disableDepthTest();
+		GlStateManager.disableLighting();
+		GlStateManager.color4f(1, 1, 1, 1);
+
+		this.mc.getTextureManager().bindTexture(Gui.ICONS);
+		float menuMousePointerSize = 16f * this.mc.vrSettings.menuCrosshairScale;
+		
+		//Why didnt we think of this sooner?
+		/*GlStateManager.colorMask(false, false, false, true);
+		GlStateManager.blendFunc(SourceFactor.CONSTANT_ALPHA, DestFactor.ZERO);
+		drawCentredTexturedModalRect(mouseX, mouseY, menuMousePointerSize, menuMousePointerSize, 0, 0, 15, 15);
+		
+		GlStateManager.blendFunc(SourceFactor.ONE_MINUS_DST_COLOR, DestFactor.ONE_MINUS_SRC_COLOR);
+		GlStateManager.colorMask(true, true, true, false);
+		drawCentredTexturedModalRect(mouseX, mouseY, menuMousePointerSize, menuMousePointerSize, 0, 0, 15, 15);*/
+
+		// Turns out all we needed was some blendFuncSeparate magic :)
+		// Also color DestFactor of ZERO produces better results with non-white crosshairs
+		GlStateManager.blendFuncSeparate(SourceFactor.ONE_MINUS_DST_COLOR, DestFactor.ZERO, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+		drawCentredTexturedModalRect(mouseX, mouseY, menuMousePointerSize, menuMousePointerSize, 0, 0, 15, 15);
+
+		GlStateManager.disableBlend();
+		GlStateManager.blendFuncSeparate(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+		GlStateManager.enableDepthTest();
+		GlStateManager.enableLighting();
+		//GlStateManager.colorMask(true, true, true, false);
+	}
+	/**
+	 * Draws a centred textured rectangle at the stored z-value. Args: x, y, width, height, u, v, texwidth, texheight
+	 */
+	public void drawCentredTexturedModalRect(int centreX, int centreY, float width, float height, int u, int v, int texWidth, int texHeight)
+	{   	
+		float f = 0.00390625F;
+		float f1 = 0.00390625F;
+		Tessellator tessellator = Tessellator.getInstance();
+		tessellator.getBuffer().begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);
+		tessellator.getBuffer().pos(0, 0, 0).tex(u, v);
+		tessellator.getBuffer().pos((double)(centreX - (width / 2f)), (double)(centreY + (height / 2f)), (double)this.zLevel).tex((double)((float)(u + 0) * f), (double)((float)(v + texHeight) * f1)).endVertex();
+		tessellator.getBuffer().pos((double)(centreX + (width / 2f)), (double)(centreY + (height / 2f)), (double)this.zLevel).tex( (double)((float)(u + texWidth) * f), (double)((float)(v + texHeight) * f1)).endVertex();
+		tessellator.getBuffer().pos((double)(centreX + (width / 2f)), (double)(centreY - (height / 2f)), (double)this.zLevel).tex( (double)((float)(u + texWidth) * f), (double)((float)(v + 0) * f1)).endVertex();
+		tessellator.getBuffer().pos((double)(centreX - (width / 2f)), (double)(centreY - (height / 2f)), (double)this.zLevel).tex( (double)((float)(u + 0) * f), (double)((float)(v + 0) * f1)).endVertex();
+		tessellator.draw();
+	}
 }
